<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>拾荒志</title>
  
  <subtitle>虚怀若谷，大智若愚</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://murphypei.github.io/"/>
  <updated>2020-04-12T05:53:33.963Z</updated>
  <id>https://murphypei.github.io/</id>
  
  <author>
    <name>murphypei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈内存对齐</title>
    <link href="https://murphypei.github.io//blog/2020/04/memory-align.html"/>
    <id>https://murphypei.github.io//blog/2020/04/memory-align.html</id>
    <published>2020-04-12T04:14:38.000Z</published>
    <updated>2020-04-12T05:53:33.963Z</updated>
    
    <content type="html"><![CDATA[<p>C/C++ 编程中常见的一个概念是内存对齐，这里的对齐简单来讲就是分配的内存地址的起始位置是某个数字的倍数。</p><a id="more"></a><h3 id="为什么要内存对齐"><a href="#为什么要内存对齐" class="headerlink" title="为什么要内存对齐"></a>为什么要内存对齐</h3><p>我们知道计算内存的最小存储单位是字节（byte），一般来讲我们调用 <code>malloc</code> 这类分配内存的函数也是以字节为单位分配的。理论上来讲我们分配的内存是由内核的堆管理器管理的，所以分配的内存首地址可能是任意的，也就是所谓的<strong>没有对齐</strong>。我们还知道，C 语言的 <code>struct</code> 中会有内存对齐，存在比如每个成员的起始地址必须是其大小的倍数，整个 <code>struct</code> 大小是最大成员的倍数等规则。这其中的原因是什么呢？</p><p>其实这和计算机体系结构或者说硬件设计有关。首先，<strong>很多 CPU 只从对齐的地址开始加载数据</strong>，CPU 这样做是为了更快一点。其次，<strong>外部总线从内存一次获取的数据往往不是 1 byte，而是 4 bytes 或许 8 bytes 或者更多</strong>，具体和数据总线带宽有关，32 位计算体系中数据总线一般就是 32 bits，也就是 4 bytes。</p><p>有了以上两个原因，我们容易理解为啥要数据对齐了。比如一个 int 数据类型，其分配的 4 bytes 没有对齐，比如分配在 3，4，5，6 这 4 个字节上。而 CPU 取值是对齐的，可能就需要取 0~3，4~7 这两块的数据才能获得这个 int 数据的大小。</p><h3 id="向量指令"><a href="#向量指令" class="headerlink" title="向量指令"></a>向量指令</h3><p>以上内存对齐的需求只是最基本，常见于 C 语言编程中，现代编译器一般会处理这类的内存对齐。另一种需要程序员处理的内存对齐就是向量指令集。我们以 x86 平台的向量化运算为例。</p><p>向量化运算就是用 SSE、AVX 等 SIMD（Single Instruction Multiple Data）指令集，实现一条指令对多个操作数的运算，从而提高代码的吞吐量，实现加速效果。SSE 是一个系列，包括从最初的 SSE 到最新的 SSE4.2，支持同时操作 16 bytes 的数据，即 4 个 float 或者 2 个 double。AVX 也是一个系列，它是 SSE 的升级版，支持同时操作 32 bytes 的数据，即 8 个 float 或者 4 个 double。</p><p>但<strong>向量化运算是有前提的，那就是内存对齐</strong>。SSE 的操作数，必须 16 bytes 对齐，而 AVX 的操作数，必须 32 bytes 对齐。也就是说，如果我们有 4 个 float 数，必须把它们放在连续的且首地址为 16 的倍数的内存空间中，才能调用 SSE 的指令进行运算。</p><h3 id="栈上内存对齐"><a href="#栈上内存对齐" class="headerlink" title="栈上内存对齐"></a>栈上内存对齐</h3><p>简单以 4 个浮点数相加为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;immintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> input1[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">  <span class="keyword">double</span> input2[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  <span class="keyword">double</span> result[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"address of input1: "</span> &lt;&lt; input1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"address of input2: "</span> &lt;&lt; input2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  __m256d a = _mm256_load_pd(input1);</span><br><span class="line">  __m256d b = _mm256_load_pd(input2);</span><br><span class="line">  __m256d c = _mm256_add_pd(a, b);</span><br><span class="line"></span><br><span class="line">  _mm256_store_pd(result, c);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; result[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; result[<span class="number">1</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; result[<span class="number">2</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; result[<span class="number">3</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>_mm256_*</code> 就是 AVX 向量指令的封装函数。<code>_mm256_load_pd</code> 指令用来加载操作数，<code>_mm256_add_pd</code> 指令进行向量化运算，最后， <code>_mm256_store_pd</code> 指令读取运算结果到 <code>result</code> 中。可惜的是，程序运行到第一个 <code>_mm256_load_pd</code> 处就崩溃了。崩溃的原因正是因为输入的变量没有内存对齐。那如何是我们的变量对齐呢？我们可以借助编译的一些特性来实现。比如 GCC 的语法为<code>__attribute__((aligned(32)))</code>，MSVC的语法为 <code>__declspec(align(32))</code>。以 GCC 语法为例，做少量修改，就可以得到正确的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;immintrin.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  __attribute__ ((aligned (<span class="number">32</span>))) <span class="keyword">double</span> input1[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">  __attribute__ ((aligned (<span class="number">32</span>))) <span class="keyword">double</span> input2[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  __attribute__ ((aligned (<span class="number">32</span>))) <span class="keyword">double</span> result[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"address of input1: "</span> &lt;&lt; input1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"address of input2: "</span> &lt;&lt; input2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  __m256d a = _mm256_load_pd(input1);</span><br><span class="line">  __m256d b = _mm256_load_pd(input2);</span><br><span class="line">  __m256d c = _mm256_add_pd(a, b);</span><br><span class="line"></span><br><span class="line">  _mm256_store_pd(result, c);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; result[<span class="number">0</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; result[<span class="number">1</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; result[<span class="number">2</span>] &lt;&lt; <span class="string">" "</span> &lt;&lt; result[<span class="number">3</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然上面只是示例代码，可以通过类型定义等方法优化代码的写法等等。</p><h3 id="堆上内存对齐"><a href="#堆上内存对齐" class="headerlink" title="堆上内存对齐"></a>堆上内存对齐</h3><p>以上通过编译器的修饰语法来解决内存对齐，貌似很简单，但是还是存在一个问题。以上的两个数组变量都是局部变量，也就是分配在<strong>栈上，内存地址由编译器在编译时确定</strong>，因此预编译指令会生效。但用new 和 malloc 动态创建的对象则存储在堆中，其地址在运行时确定。C++ 的运行时库并不会关心预编译指令声明的对齐方式，我们需要更强有力的手段来确保内存对齐。</p><p>废话不多说，我这里以 MNN 中的内存对齐代码为例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> **<span class="title">alignPointer</span><span class="params">(<span class="keyword">void</span> **ptr, <span class="keyword">size_t</span> alignment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">void</span> **)((<span class="keyword">intptr_t</span>)((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)ptr + alignment - <span class="number">1</span>) &amp; -alignment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> *<span class="title">MNNMemoryAllocAlign</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">size_t</span> alignment)</span> </span>&#123;</span><br><span class="line">    MNN_ASSERT(size &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MNN_DEBUG_MEMORY</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">void</span> **origin = (<span class="keyword">void</span> **)<span class="built_in">malloc</span>(size + <span class="keyword">sizeof</span>(<span class="keyword">void</span> *) + alignment);</span><br><span class="line">    MNN_ASSERT(origin != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!origin) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> **aligned = alignPointer(origin + <span class="number">1</span>, alignment);</span><br><span class="line">    aligned[<span class="number">-1</span>]    = origin;</span><br><span class="line">    <span class="keyword">return</span> aligned;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们分析一下以上代码。首先，为了保证内存对齐，我们可以在 <code>malloc</code> 分配时分配比所要求的内存大的内存容量，这样我们可以向下寻找一个保证是对齐大小的整倍数的内存地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">void</span> **)<span class="built_in">malloc</span>(size + <span class="keyword">sizeof</span>(<span class="keyword">void</span> *) + alignment)</span><br></pre></td></tr></table></figure><p>然后我们向下寻找满足对齐需求的首地址，代码就是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">void</span> **)((<span class="keyword">intptr_t</span>)((<span class="keyword">unsigned</span> <span class="keyword">char</span> *)ptr + alignment - <span class="number">1</span>) &amp; -alignment)</span><br></pre></td></tr></table></figure><p><code>&amp;</code> 符号是按位与，<code>-alignment</code> 的补码表示就是 <code>aliginment</code> 符号位不变，其余位按位取反并加 1。我们以 AVX 所需要的 32 bytes 对齐为例，<code>alignment</code> 就是 256，二进制就是 <code>0...00000100000000</code>，<code>-alignment</code> 在计算中的表示就是 <code>1...11111100000000</code>，也就是后 8 位为 0，其余位为均为 1， 因此任何数与 <code>-alignment</code> 按位与的后 8 为都为 0，所以结果肯定是 32 bytes 对齐的。<code>((unsigned char *)ptr + alignment - 1) &amp; -alignment</code> 就相当于把 <code>ptr + alignment - 1</code> 的后 8 位置为 0，这个数比 <code>ptr + alignment - 1</code> 小，而且一定是对齐的。</p><p>通过以上代码，我们可以获取一块在堆上新创建的并且地址对齐的内存。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C/C++ 编程中常见的一个概念是内存对齐，这里的对齐简单来讲就是分配的内存地址的起始位置是某个数字的倍数。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://murphypei.github.io/categories/C-C/"/>
    
    
      <category term="C/C++" scheme="https://murphypei.github.io/tags/C-C/"/>
    
      <category term="内存对齐" scheme="https://murphypei.github.io/tags/%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90/"/>
    
      <category term="内存寻址" scheme="https://murphypei.github.io/tags/%E5%86%85%E5%AD%98%E5%AF%BB%E5%9D%80/"/>
    
      <category term="memory aligin" scheme="https://murphypei.github.io/tags/memory-aligin/"/>
    
  </entry>
  
  <entry>
    <title>最大似然估计和最大后验概率估计</title>
    <link href="https://murphypei.github.io//blog/2020/03/mle-map.html"/>
    <id>https://murphypei.github.io//blog/2020/03/mle-map.html</id>
    <published>2020-03-18T11:38:13.000Z</published>
    <updated>2020-04-12T04:21:37.605Z</updated>
    
    <content type="html"><![CDATA[<p>最大似然估计和最大后验概率估计是概率论中应用很广泛的两个理论，之前的理解似是而非，因此查阅了一些资料，总结记录。</p><a id="more"></a><h3 id="最大似然估计"><a href="#最大似然估计" class="headerlink" title="最大似然估计"></a>最大似然估计</h3><p>最大似然估计（Maximum likelihood estimation, 简称 MLE）是概率论中最常见的应用理论之一，另一个是<a href="https://murphypei.github.io/blog/2020/03/bayes-theorem.html">贝叶斯定理</a>。最大似然估计通俗理解就是<strong>利用已知的样本结果信息，反推最有可能导致这个结果出现的模型参数</strong>。</p><p>换个角度想一想，在机器学习和深度学习任务中，我们学习的是什么？当一个模型确定的时候，我们学习的就是模型的参数啊。<strong>换句话说，极大似然估计提供了一种给定观察数据来评估模型参数的方法，即：“模型已定，参数未知”。</strong></p><p>似然（likelihood）这个词其实和概率（probability）是差不多的意思，Colins字典这么解释：The likelihood of something happening is how likely it is to happen. 你把 likelihood 换成 probability，这解释也读得通。但是<strong>在统计里面，似然函数和概率函数却是两个不同的概念</strong>（其实也很相近就是了）。</p><p>对于函数  $P(x|\theta)$，输入有两个：$x$ 表示某一个具体的数据，$\theta$ 表示模型的参数。</p><ul><li>如果 $\theta$ 是已知确定的，$x$ 是变量，这个函数就称为概率函数（probability function），它描述对于不同的样本点 $x$，其出现的概率是多少。</li><li>如果 $x$ 是已知确定的，$\theta$ 是变量，这个函数就称为似然函数（likelihood function），它描述对于不同的模型参数，出现 $x$ 这个样本点的概率是多少。</li></ul><blockquote><p>上述的表述看上去似乎在玩文字游戏，但是其实也不难理解，举个抛硬币的例子。</p><p>如果抛一枚硬币出现正面的概率是 0.5（参数确定），则抛 10 次硬币，出现 10 次正面的概率是多少呢？ $0.5^{10}$ ，这就是概率函数。</p><p>如果是抛 10 次硬币出现了 10 次正面，那么什么硬币最可能出现这种情况呢？（参数未知），很明显，硬币不规则，导致出现正面的概率极大，或者说一定会出现正面。这里需要求解的就是抛硬币出现正面的概率。</p></blockquote><p>好了，理解了上述的思想，我们就可以很容易理解最大似然估计，或者说上述的例子其实已经说明了最大似然估计怎么使用。下面对上述抛硬币的例子进行深入解析。</p><p>假设有一个造币厂生产某种硬币，现在我们拿到了一枚这种硬币，想试试这硬币是不是均匀的。即想知道抛这枚硬币，正反面出现的概率（记为 $\theta$ ）各是多少？</p><p>这就是日常中常见的一个需要用统计学习方法解决的实际例子，就是<strong>实际日常中，模型的参数往往都是未知的，但是我们可以通过做统计实验得到观察数据</strong>。</p><p>现在我们拿这枚硬币抛了 10 次，得到的观察数据（记为 $x$ ）是：反正正正正反正正正反。我们想求的正面概率。</p><p>首先假设模型，记住，最大似然估计是在给定模型的情况下估计参数。抛硬币可以假设是一个二项分布，合情合理。那么，出现实验结果 $x_0$（即反正正正正反正正正反）的<strong>似然函数</strong>是多少呢？</p><script type="math/tex; mode=display">f(x, \theta) = (1-\theta) \times \theta \times \theta \times \theta \times \theta \times (1-\theta) \times \theta \times \theta \times \theta \times (1-\theta) = \theta^7(1-\theta)^3 = f(\theta)</script><p>这里要注意，这里 $f$ 是似然函数， $x$ 是已知量，$\theta$ 是未知量，因此是一个关于 $\theta$ 的函数。最大似然估计，顾名思义就是最大化这个函数，我们可以画出 $f(\theta)$ 的图像：</p><p><img src="/images/posts/ml/mle_map/theta_mle.png" alt></p><p>可以看出，在 $\theta=0.7$ 时，似然函数取得最大值。</p><p>这样，我们已经完成了对 $\theta$ 的最大似然估计。即抛 10 次硬币，发现 7 次硬币正面向上，最大似然估计认为正面向上的概率是 0.7，看上去也很符合直觉。</p><p>且慢，一些人可能会说，硬币一般都是均匀的啊！ 就算你做实验发现结果是“反正正正正反正正正反”，我也不信 $\theta = 0.7$，<strong>因为 $\theta=0.7$ 这件事本身比 $\theta=0.5$ 这件事更加难以置信</strong>。为此，我们就需要引入贝叶斯学派的思想了——要考虑先验概率。 为此，引入了<strong>最大后验概率估计</strong>（Maximum a posteriori estimation, 简称MAP）。</p><h3 id="最大后验概率估计"><a href="#最大后验概率估计" class="headerlink" title="最大后验概率估计"></a>最大后验概率估计</h3><p>最大似然估计是单纯根据出现的事件求参数 $\theta$，使似然函数 $P(x|\theta)$ 最大。最大后验概率估计在最大似然估计的基础上，求得的 $\theta$ 不仅仅是让似然函数最大，也让 $\theta$ 自己出现的概率最大。我们可以换个角度来思考这个问题，对于不同的 $\theta$ 可以得到不同的似然函数的值，但是 $\theta$ 本身出现的概率可以用来对似然函数进行正则化，让似然函数更加合理，本身出现概率小的 $\theta$ 会引入惩罚，降低其似然函数的值。但是与损失函数中正则化项一般用加法不同，MAP 里利用乘法引入这个惩罚因子。</p><p>MAP 定义是最大化一个函数：</p><script type="math/tex; mode=display">P(\theta|x)=\frac{P(x|\theta)P(\theta)}{P(x)}</script><p>因为 $x$ 是确定的观察事件。因此 $P(x)$ 是已知值，所以可以去掉分母。</p><blockquote><p>假设”投 10 次硬币“是一次实验，实验做了 1000 次，“反正正正正反正正正反”出现了 n 次，则$P(x)=n / 1000$。总之，这是一个可以由实验观察数据集得到的值。</p></blockquote><p>上述的公式是不是很像贝叶斯定理？最大后验概率的名字由来就是最大化 $P(\theta|x)$，这其实是一个后验概率。与似然函数 $P(x|\theta)$ 不同的也仅仅是乘以先验概率 $P(\theta)$。</p><p>先验概率我们可以通过假设一个高斯分布来描述。假设 $P(\theta)$ 为均值 0.5，方差 0.1 的高斯函数（万能的假设函数…），如下图：</p><p><img src="/images/posts/ml/mle_map/theta_gaussian.png" alt></p><p>则 $P(x|\theta)P(\theta)$ 的函数图像是：</p><p><img src="/images/posts/ml/mle_map/theta_map.png" alt></p><p>注意，此时函数取最大值时，$\theta$ 取值已向左偏移，不再是 0.7。实际上，在 $\theta=0.558$ 时函数取得了最大值。即用最大后验概率估计，得到 $θ=0.558$ 。最后，那要怎样才能说服一个贝叶斯派相信 $θ=0.7$ 呢？你得多做点实验，让似然函数更加集中。比如做了1000次实验，其中700次都是正面向上，这时似然函数为：</p><p><img src="/images/posts/ml/mle_map/1000_theta_mle.png" alt></p><p>这样即使乘以先验概率的惩罚项，得到的结果还是 $\theta=0.7$ 最大（实际乘的结果是 0.696，如果还不信，继续加大实验次数）。</p><p>当然，从我们的计算中可以看出，MAP 是同时受先验概率和似然函数的影响，如果先验概率不合理，比如 $P(\theta=0.7)=0$，那么做多少次实验都没有意义了…</p><h4 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h4><ul><li><a href="https://blog.csdn.net/u011508640/article/details/72815981" target="_blank" rel="noopener">https://blog.csdn.net/u011508640/article/details/72815981</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最大似然估计和最大后验概率估计是概率论中应用很广泛的两个理论，之前的理解似是而非，因此查阅了一些资料，总结记录。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://murphypei.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://murphypei.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="最大似然" scheme="https://murphypei.github.io/tags/%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6/"/>
    
      <category term="最大后验概率" scheme="https://murphypei.github.io/tags/%E6%9C%80%E5%A4%A7%E5%90%8E%E9%AA%8C%E6%A6%82%E7%8E%87/"/>
    
      <category term="概率论" scheme="https://murphypei.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>贝叶斯定理</title>
    <link href="https://murphypei.github.io//blog/2020/03/bayes-theorem.html"/>
    <id>https://murphypei.github.io//blog/2020/03/bayes-theorem.html</id>
    <published>2020-03-14T11:38:13.000Z</published>
    <updated>2020-04-12T04:21:22.414Z</updated>
    
    <content type="html"><![CDATA[<p>贝叶斯定理的理解对于概率计算是非常重要，而且日常使用非常常见。</p><a id="more"></a><h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>我们日常计算概率，最简单的就是正向概率。比如一个抽奖活动，抽奖桶里有 10 个球，其中 2 个白球，8 个黑球，抽到白球就算你中奖。你伸手进去随便摸出 1 颗球，摸出中奖球的概率是多大。根据概率计算公式可知是 2/10。</p><p><strong>正向概率是已知事件空间的概率分布，求某个事件发生的概率</strong>，这在日常生活中并不常见，除了抽奖。日常常见的是发生了某件事，比如天上有乌云，我要知道下雨的概率。这类<strong>利用有限的信息预测可能发生的事件概率</strong>在生活中无处不在，也是算法所要解决的问题，而贝叶斯定理解决的是就是这类问题。贝叶斯定理的用处可以总结为一句话：<strong>在有限的信息下，能够帮助我们预测出概率</strong>。</p><h3 id="贝叶斯定理"><a href="#贝叶斯定理" class="headerlink" title="贝叶斯定理"></a>贝叶斯定理</h3><script type="math/tex; mode=display">P(A|B) = P(A) \frac {P(B|A)} {P(B)}</script><p>在介绍贝叶斯定理之前，简单介绍概率论相关知识点：</p><ul><li>$P(A)$ 表示事件 A 发生的概率。</li><li>$P(AB)$ 表示事件 A 和事件 B 同时发生的概率。</li><li>$P(B|A)$ 表示在事件 A 发生的前提下，事件 B 发生的概率。</li></ul><p>很明显，贝叶斯定理所要求解的问题就是$P(A|B)$ 这种概率，也就是在已知事件 B 的情况下，求事件 A 发生的概率。为此，我们还需要了解一些关于概率的名词。</p><h4 id="先验概率"><a href="#先验概率" class="headerlink" title="先验概率"></a>先验概率</h4><p>$P(A)$ 是先验概率（prior probability），先验概率就是已知的概率分布，比如投一个正常骰子的每个点数的概率是 1/6，抛一枚正常硬币正面和反面的概率都是 1/2。</p><h4 id="可能性函数"><a href="#可能性函数" class="headerlink" title="可能性函数"></a>可能性函数</h4><p>$P(B|A)/P(B)$ 称为“可能性函数”（likelyhood），这是一个调整因子，即新信息 $B$ 带来的调整，作用 是<strong>使得先验概率更接近真实概率</strong>。 可能性函数你可以理解为新信息过来后，对先验概率的一个调整。</p><h4 id="后验概率"><a href="#后验概率" class="headerlink" title="后验概率"></a>后验概率</h4><p>$P(A|B)$ 是后验概率（posterior probability），即在 B 事件发生之后，我们对 A 事件概率的重新评估，也就是贝叶斯定理求解所期望的更加真实的概率。</p><p>现在我们再看一遍贝叶斯公式，你现在就能明白这个公式背后的最关键思想了： 我们先根据以往的经验预估一个先验概率 $P(A)$，然后加入新的信息（事件 B），这样有了新的信息后，我们对事件 A 的预测就更加准确。 因此，贝叶斯定理可以理解成下面的式子： </p><p><strong>后验概率（新信息出现后的A概率）＝ 先验概率（A概率）ｘ 可能性函数（新信息带来的调整）</strong></p><p>为什么需要像贝叶斯这样做呢？前面已经解释了，一个事件比如下雨，发生的概率是受非常多因素的影响，那么我们如果预测天气呢，其实就是把能够考虑到的信息都计算进去，然后不断修正先验概率，得到后验概率。这里有一个朴素的思想：如果我能掌握一个事情的全部信息，我当然能计算出一个客观概率（古典概率）。但是当我们手中只有有限的信息。既然无法得到全面的信息，我们就在信息有限的情况下，尽可能做出一个好的预测。也就是，在主观判断的基础上，你可以先估计一个值，然后根据观察的新信息不断修正(可能性函数)。</p><h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><p>贝叶斯定理很简单，但是最难的是将简单的公式应用到实际解决问题当中去，这也是对定理深刻的理解。</p><h4 id="案例-1"><a href="#案例-1" class="headerlink" title="案例 1"></a>案例 1</h4><p>假设有两个一模一样的碗，1 号碗里有 30 个巧克力和 10 个水果糖，2 号碗里有 20 个巧克力和 20 个水果糖。现在随机选择一个碗，从里面摸出一个巧克力。 问这颗巧克力来自 1 号碗的概率是多少？</p><p>我们一步步来求解。</p><p>首先把问题分解，问题的事件 A 是要求取的后验概率，因此定义事件 A 就是选择了 1 号碗的概率。而事件 B 是已经发生的事，也就是摸出了一颗巧克力，因此定义事件 B 为取出一个巧克力。所以 $P(A|B)$ 就表示取出一颗巧克力，其来自 1 号碗的概率。。</p><p>现在我们先分别计算 $P(A)$ 和 $P(B)$ 。因为碗一样，所以 $P(A)$ 肯定是 1/2。$P(B)$ 用古典概率分布也很容易求出：</p><script type="math/tex; mode=display">P(B) = 0.5 \times \frac {30} {40} + 0.5 \times \frac {20} {40} = 0.625</script><p>也就是说在未知情况下，取出巧克力的先验概率是 0.625。接着计算 $P(B|A)$ 也很简单，就是确定选择了 1 号碗，取出巧克力的概率很明显是 0.75。因此可能性函数就是：</p><script type="math/tex; mode=display">\frac {P(B|A)} {P(B)} = \frac {0.75} {0.625} = 1.2</script><p>很明显，可能性增强了。表明事件 B 对事件 A 发生的概率产生了增益。其实我们看题目也明白，1 号碗中巧克力的比例更大，因此如果选择了 1 号碗（事件 A）发生，必然取得巧克力（事件 B）的概率也变大了。</p><p>后验概率计算：</p><script type="math/tex; mode=display">P(A|B) = P(A) \frac {P(B|A)} {P(B)} = 0.5 \times 1.2 = 0.6</script><p>可以看到，如果是盲猜，那么这颗巧克力不是来自 1 号碗就是来自 2 号碗，二者概率均为 0.5。但是运用贝叶斯定理，因为两个碗里的巧克力比例不同，盲猜的先验概率得到了修正，来自 1 号碗的概率更大。这也是符合日常常识的。</p><p>总结下刚才的贝叶斯定理应用的套路：</p><ol><li>首先分解问题，简单来说就像做应用题的感觉，先列出解决这个问题所需要的一些条件，然后记清楚哪些是已知 的，哪些是未知的，已知条件是什么。</li><li>应用贝叶斯定理，求贝叶斯公式中的 2 个指标：先验概率和可能性函数，然后带入贝叶斯公式求后验概率。</li></ol><h4 id="案例-2"><a href="#案例-2" class="headerlink" title="案例 2"></a>案例 2</h4><p>假设某种疾病的发病率是 0.001，即 1000 人中会有 1 个人得病。现有一种试剂可以检验患者是否得病，它的准确率是 0.99，即在患者确实得病的情况下，它有 99% 的可能呈现阳性。它的误报率是 5%，即在患者没有得病的情况下，它有 5% 的可能呈现阳性。现有一个病人的检验结果为阳性，请 问他确实得病的可能性有多大？</p><p>我们一步步分解来看。</p><p>已知事件B：检验结果为阳性。求解事件A：确实得病。可以利用古典概率公式分别求二者的概率：</p><script type="math/tex; mode=display">P(B)=0.001 \times 0.99 + (1-0.001) \times 0.05=0.05094</script><p>右边第一项是得病的人，检测结果为阳性，第二项是没病得人，检测结果为阳性。</p><script type="math/tex; mode=display">P(A)=0.001</script><p>$P(B|A)$  就是得病了，检测结果为阳性，很明显就是0.99，因此可能性函数也可以很容易求得：</p><script type="math/tex; mode=display">\frac{P(B|A)}{P(B)} =\frac{0.99}{0.05094}=19.435</script><p>最后运用贝叶斯公式：</p><script type="math/tex; mode=display">P(A|B) = P(A) \frac {P(B|A)} {P(B)} = 0.001 \times 19.435 = 0.0194</script><p>也就是检测正确率很高的情况下，检测结果成阳性，其真正得病的概率也才 0.0194，这是不是很不符合我们平时的感觉？这就是贝叶斯公式的厉害之处。我们看一下这里问题出在哪里呢？其实很简单，就是真实得病率太低了，虽然检测结果为阳性这个事件已经将其发生概率提升了 19 倍多。这就是为什么医学检查通常要做很多次，特别是像艾滋病这种发病率很低的病。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>贝叶斯定理因为其强大的内在原理和广泛的应用场景，因此成为机器学习的基础，衍生出很多应用方式。其实更厉害的是其思想，也就是分解问题、主观判断、搜集信息、修正判断。这一套逻辑不仅仅是概率，更是日常生活中我们做事情、学习的逻辑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;贝叶斯定理的理解对于概率计算是非常重要，而且日常使用非常常见。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://murphypei.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://murphypei.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="概率论" scheme="https://murphypei.github.io/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
      <category term="贝叶斯定理" scheme="https://murphypei.github.io/tags/%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>父类成员函数调用子类成员函数</title>
    <link href="https://murphypei.github.io//blog/2020/03/call-derived-function.html"/>
    <id>https://murphypei.github.io//blog/2020/03/call-derived-function.html</id>
    <published>2020-03-07T11:38:13.000Z</published>
    <updated>2020-04-12T04:18:21.558Z</updated>
    
    <content type="html"><![CDATA[<p>最近遇到一个很有意思的问题，如果在父类成员函数中调用子类成员函数。这个应用场景不是很常见，但是有一些方法可以实现。</p><a id="more"></a><h4 id="通过函数指针"><a href="#通过函数指针" class="headerlink" title="通过函数指针"></a>通过函数指针</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明子类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 声明子类对象指针</span></span><br><span class="line">    Derived *d;</span><br><span class="line">    <span class="comment">// 声明子类型的函数指针</span></span><br><span class="line">    <span class="keyword">void</span> (Derived::*f)(<span class="keyword">int</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过子类型对象和函数指针调用子类型函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        (d-&gt;*f)(<span class="number">123</span>); <span class="comment">// 注意调用的写法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> i)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived f2: "</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为继承得到的父类型的成员变量赋值</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        d = <span class="keyword">this</span>;</span><br><span class="line">        f = &amp;Derived::f2;<span class="comment">// 注意这里 &amp; 后面不能加括号</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    d.f3();</span><br><span class="line">    d.f1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Derived f2: 123</span><br></pre></td></tr></table></figure><p>思路是这样的，在父类中声明子类成员变量指针和函数指针，并在父类成员方法中通过函数指针去调用。然后在子类中给继承得到的这些成员变量赋值，这样子类调用父类的方法的时候就能实现调用子类方法。</p><p>这里说两个关于类成员函数指针的知识点：</p><blockquote><ol><li>函数指针赋值要使用 <strong>&amp;</strong></li><li>使用 <strong>.*</strong> (实例对象)或者 <strong>-&gt;*</strong>（实例对象指针）调用类成员函数指针所指向的函数</li></ol></blockquote><h4 id="通过模板类"><a href="#通过模板类" class="headerlink" title="通过模板类"></a>通过模板类</h4><p>其实这个问题本来是让我用模板类实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T *t;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Base f1: "</span>&lt;&lt; t-&gt;val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="comment">// 模板类型即使看不到声明也可以调用</span></span><br><span class="line">        t-&gt;f2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">public</span> Base&lt;Derived&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Derived f2: "</span> &lt;&lt; val &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        val = <span class="number">123</span>;</span><br><span class="line">        t = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Derived d;</span><br><span class="line">    d.f3();</span><br><span class="line">    d.f1();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Base f1: 123</span><br><span class="line">Derived f2: 123</span><br></pre></td></tr></table></figure><p>其实思路类似，就是在父类中需要有一个占位符能表示子类。在前面函数指针实现中，我们用子类指针和函数指针作为声明（需要前置声明子类）占位符。而利用模板，我们不需要函数指针，模板类型本身就可以作为一种占位符。我们将模板类型当作子类类型，直接在父类成员中调用子类函数。另外，我们在子类定义时，继承的父类是利用子类模板实例化的一个类，然后在子类中给模板类型赋值为当前对象指针，这样就实现了调用。</p><p>其实这里我们主要是利用 t 是模板类型 T 的指针，这样即使不知道 t 的具体定义，也可以访问到其成员，可以调用到其方法，若非通过模板，就不能这样。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近遇到一个很有意思的问题，如果在父类成员函数中调用子类成员函数。这个应用场景不是很常见，但是有一些方法可以实现。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://murphypei.github.io/categories/C-C/"/>
    
    
      <category term="C++11" scheme="https://murphypei.github.io/tags/C-11/"/>
    
      <category term="模板" scheme="https://murphypei.github.io/tags/%E6%A8%A1%E6%9D%BF/"/>
    
      <category term="函数指针" scheme="https://murphypei.github.io/tags/%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>C++ 右值引用使用总结</title>
    <link href="https://murphypei.github.io//blog/2020/02/right-reference.html"/>
    <id>https://murphypei.github.io//blog/2020/02/right-reference.html</id>
    <published>2020-02-24T11:38:13.000Z</published>
    <updated>2020-04-12T04:18:21.558Z</updated>
    
    <content type="html"><![CDATA[<p>一篇关于 C++11 右值引用的一篇总结，觉得其中对于常见误用的总结很不错，想起来了当年自己走过的一些坑，转载做个记录。</p><a id="more"></a><h3 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h3><blockquote><p>如果你还不知道 C++ 11 引入的右值引用是什么，可以读读这篇文章，看看有什么 <strong>启发</strong>；如果你已经对右值引用了如指掌，也可以读读这篇文章，看看有什么 <strong>补充</strong>。欢迎交流~ </p></blockquote><p>尽管 C++ 17 标准已经发布了，很多人还不熟悉 C++ 11 的 <strong>右值引用/移动语义/拷贝省略/通用引用/完美转发</strong> 等概念，甚至对一些细节 <strong>有所误解</strong>（包括我）。</p><p>本文将以最短的篇幅，一步步解释 关于右值引用的 <strong>为什么/是什么/怎么做</strong>。先分享几个我曾经犯过的错误。</p><h4 id="误解1：返回前，移动局部变量"><a href="#误解1：返回前，移动局部变量" class="headerlink" title="误解1：返回前，移动局部变量"></a>误解1：返回前，移动局部变量</h4><blockquote><p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-move" target="_blank" rel="noopener">ES.56: Write <code>std::move()</code> only when you need to explicitly move an object to another scope</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> base_url = tag-&gt;GetBaseUrl();</span><br><span class="line"><span class="keyword">if</span> (!base_url.empty()) &#123;</span><br><span class="line">  UpdateQueryUrl(<span class="built_in">std</span>::move(base_url) + <span class="string">"&amp;q="</span> + word_);</span><br><span class="line">&#125;</span><br><span class="line">LOG(INFO) &lt;&lt; base_url;  <span class="comment">// |base_url| may be moved-from</span></span><br></pre></td></tr></table></figure><p>上述代码的问题在于：使用 <code>std::move()</code> 移动局部变量 <code>base_url</code>，会导致后续代码不能使用该变量；如果使用，会出现 <strong>未定义行为</strong> <em>(undefined behavior)</em>（参考：<a href="https://en.cppreference.com/w/cpp/string/basic_string/basic_string" target="_blank" rel="noopener"><code>std::basic_string(basic_string&amp;&amp;)</code></a>）。</p><p>如何检查 <strong>移动后使用</strong> <em>(use after move)</em>：</p><ul><li>运行时，在 移动构造/移动赋值 函数中，将被移动的值设置为无效状态，并在每次使用前检查有效性</li><li>编译时，使用 Clang 标记对移动语义进行静态检查（参考：<a href="https://clang.llvm.org/docs/AttributeReference.html#consumed-annotation-checking" target="_blank" rel="noopener">Consumed Annotation Checking | Attributes in Clang</a>）</li></ul><h4 id="误解2：被移动的值不能再使用"><a href="#误解2：被移动的值不能再使用" class="headerlink" title="误解2：被移动的值不能再使用"></a>误解2：被移动的值不能再使用</h4><blockquote><p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-move-semantic" target="_blank" rel="noopener">C.64: A move operation should move and leave its source in a valid state</a></p></blockquote><p>很多人认为：被移动的值会进入一个 <strong>非法状态</strong> <em>(invalid state)</em>，对应的 <strong>内存不能再访问</strong>。</p><p>其实，C++ 标准要求对象 遵守 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#移动语义" target="_blank" rel="noopener">§ 3</a> <strong>移动语义</strong> —— 被移动的对象进入一个 <strong>合法但未指定状态</strong> <em>(valid but unspecified state)</em>，调用该对象的方法（包括析构函数）不会出现异常，甚至在重新赋值后可以继续使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> q = <span class="built_in">std</span>::move(p);</span><br><span class="line"></span><br><span class="line">assert(p == <span class="literal">nullptr</span>);  <span class="comment">// OK: reset to default</span></span><br><span class="line">p.reset(<span class="keyword">new</span> <span class="keyword">int</span>&#123;<span class="number">2</span>&#125;);   <span class="comment">// or p = std::make_unique&lt;int&gt;(2);</span></span><br><span class="line">assert(*p == <span class="number">2</span>);       <span class="comment">// OK: reset to int*(2)</span></span><br></pre></td></tr></table></figure><p>另外，基本类型（例如 <code>int/double</code>）的移动语义 和拷贝相同：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> j = <span class="built_in">std</span>::move(i);</span><br><span class="line"></span><br><span class="line">assert(i == j);</span><br></pre></td></tr></table></figure><h4 id="误解3：移动非引用返回值"><a href="#误解3：移动非引用返回值" class="headerlink" title="误解3：移动非引用返回值"></a>误解3：移动非引用返回值</h4><blockquote><p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-return-move-local" target="_blank" rel="noopener">F.48: Don’t <code>return std::move(local)</code></a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; foo() &#123;</span><br><span class="line">  <span class="keyword">auto</span> ret = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::move(ret);  <span class="comment">// -&gt; return ret;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的问题在于：没必要使用 <code>std::move()</code> 移动非引用返回值。</p><p>C++ 会把即将离开作用域的 <strong>非引用类型的</strong> 返回值当成 <strong>右值</strong>（参考 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#值类别-vs-变量类型" target="_blank" rel="noopener">§ 2.1</a>），对返回的对象进行 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#移动语义" target="_blank" rel="noopener">§ 3</a> 移动构造（语言标准）；如果编译器允许 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#拷贝省略" target="_blank" rel="noopener">§ 4</a> 拷贝省略，还可以省略这一步的构造，直接把 <code>ret</code> 存放到返回值的内存里（编译器优化）。</p><blockquote><p>Never apply <code>std::move()</code> or <code>std::forward()</code> to local objects if they would otherwise be eligible for the return value optimization. —— Scott Meyers, <em>Effective Modern C++</em></p></blockquote><p>另外，误用 <code>std::move()</code> 会 <strong>阻止</strong> 编译器的拷贝省略 <strong>优化</strong>。不过聪明的 Clang 会提示 <a href="https://developers.redhat.com/blog/2019/04/12/understanding-when-not-to-stdmove-in-c/" target="_blank" rel="noopener"><code>-Wpessimizing-move</code>/<code>-Wredundant-move</code></a> 警告。</p><h4 id="误解4：不移动右值引用参数"><a href="#误解4：不移动右值引用参数" class="headerlink" title="误解4：不移动右值引用参数"></a>误解4：不移动右值引用参数</h4><blockquote><p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rf-consume" target="_blank" rel="noopener">F.18: For “will-move-from” parameters, pass by <code>X&amp;&amp;</code> and <code>std::move()</code> the parameter</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; bar(<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;&amp;&amp; val) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">return</span> val;    <span class="comment">// not compile</span></span><br><span class="line">                 <span class="comment">// -&gt; return std::move/forward(val);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的问题在于：没有对返回值使用 <code>std::move()</code>（编译器提示 <code>std::unique_ptr(const std::unique_ptr&amp;) = delete</code> 错误）。</p><blockquote><p><a href="http://thbecker.net/articles/rvalue_references/section_05.html#no_name" target="_blank" rel="noopener">If-it-has-a-name Rule</a>:</p><ul><li>Named rvalue references are lvalues.</li><li>Unnamed rvalue references are rvalues.</li></ul></blockquote><p>因为不论 <strong>左值引用</strong> 还是 <strong>右值引用</strong> 的变量（或参数）在初始化后，都是左值（参考 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#值类别-vs-变量类型" target="_blank" rel="noopener">§ 2.1</a>）：</p><ul><li><strong>命名的右值引用</strong> <em>(named rvalue reference)</em> <strong>变量</strong> 是 <strong>左值</strong>，但变量类型却是 <strong>右值引用</strong>。</li><li>在作用域内，<strong>左值变量</strong> 可以通过 <strong>变量名</strong> <em>(variable name)</em> <strong>被取地址、被赋值</strong>。</li></ul><p>所以，返回右值引用变量时，需要使用 <code>std::move()</code>/<code>std::forward()</code> 显式的 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#移动转发" target="_blank" rel="noopener">§ 5.4</a> <strong>移动转发</strong> 或 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#完美转发" target="_blank" rel="noopener">§ 5.3</a> <strong>完美转发</strong>，将变量 “还原” 为右值（右值引用类型）。</p><blockquote><p>这里补充一下，这里说的是右值引用的变量，常见于函数的参数，函数参数传递会导致外面的右值引用进入函数内部作为参数变成了左值变量。</p></blockquote><h4 id="误解5：手写错误的移动构造函数"><a href="#误解5：手写错误的移动构造函数" class="headerlink" title="误解5：手写错误的移动构造函数"></a>误解5：手写错误的移动构造函数</h4><blockquote><p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-zero" target="_blank" rel="noopener">C.20: If you can avoid defining default operations, do</a></p><p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-five" target="_blank" rel="noopener">C.21: If you define or <code>=delete</code> any default operation, define or <code>=delete</code> them all</a></p><p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-eqdefault" target="_blank" rel="noopener">C.80: Use <code>=default</code> if you have to be explicit about using the default semantics</a></p><p><a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-move-noexcept" target="_blank" rel="noopener">C.66: Make move operations <code>noexcept</code></a></p></blockquote><p>实际上，多数情况下：</p><ul><li>如果 <strong>没有定义</strong> 拷贝构造/拷贝赋值/移动构造/移动赋值/析构 函数的任何一个，编译器会 <strong>自动生成</strong> 移动构造/移动赋值 函数（<a href="https://en.cppreference.com/w/cpp/language/rule_of_three#Rule_of_zero" target="_blank" rel="noopener">rule of zero</a>）</li><li>如果 <strong>需要定义</strong> 拷贝构造/拷贝赋值/移动构造/移动赋值/析构 函数的任何一个，不要忘了 移动构造/移动赋值 函数，否则对象会 <strong>不可移动</strong>（<a href="https://en.cppreference.com/w/cpp/language/rule_of_three#Rule_of_five" target="_blank" rel="noopener">rule of five</a>）</li><li><strong>尽量使用</strong> <code>=default</code> 让编译器生成 移动构造/移动赋值 函数，否则 <strong>容易写错</strong></li><li>如果 <strong>需要自定义</strong> 移动构造/移动赋值 函数，尽量定义为 <code>noexcept</code> 不抛出异常（编译器生成的版本会自动添加），否则 <strong>不能高效</strong> 使用标准库和语言工具</li></ul><p>例如，标准库容器 <code>std::vector</code> 在扩容时，会通过 <a href="https://en.cppreference.com/w/cpp/container/vector/reserve#Exceptions" target="_blank" rel="noopener"><code>std::vector::reserve()</code></a> 重新分配空间，并转移已有元素。如果扩容失败，<code>std::vector</code> 满足 <a href="https://en.cppreference.com/w/cpp/language/exceptions#Exception_safety" target="_blank" rel="noopener"><strong>强异常保证</strong> <em>(strong exception guarantee)</em></a>，可以回滚到失败前的状态。</p><p>为此，<code>std::vector</code> 使用 <a href="https://en.cppreference.com/w/cpp/utility/move_if_noexcept" target="_blank" rel="noopener"><code>std::move_if_noexcept()</code></a> 进行元素的转移操作：</p><ul><li>优先 使用 <code>noexcept</code> 移动构造函数（高效；不抛出异常）</li><li>其次 使用 拷贝构造函数（低效；如果异常，可以回滚）</li><li>再次 使用 非 <code>noexcept</code> 移动构造函数（高效；如果异常，<strong>无法回滚</strong>）</li><li>最后 如果 不可拷贝、不可移动，<strong>编译失败</strong></li></ul><p>如果 没有定义移动构造函数或自定义的移动构造函数没有 <code>noexcept</code>，会导致 <code>std::vector</code> 扩容时执行无用的拷贝，<strong>不易发现</strong>。</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><p>之所以会出现上边的误解，往往是因为 C++ 语言的复杂性和使用者对基础知识的掌握程度不匹配。</p><h4 id="值类别-vs-变量类型"><a href="#值类别-vs-变量类型" class="headerlink" title="值类别 vs 变量类型"></a>值类别 vs 变量类型</h4><p><strong>划重点</strong> —— <strong>值</strong> <em>(value)</em> 和 <strong>变量</strong> <em>(variable)</em> 是两个独立的概念：</p><ul><li>值只有 <strong>类别</strong> <em>(category)</em> 的划分，变量 只有 <strong>类型</strong> <em>(type)</em> 的划分 😵</li><li>值不一定拥有 <strong>身份</strong> <em>(identity)</em>，也不一定拥有 变量名（例如 表达式中间结果 <code>i + j + k</code>）</li></ul><p><a href="https://en.cppreference.com/w/cpp/language/value_category" target="_blank" rel="noopener"><strong>值类别</strong> <em>(value category)</em></a> 可以分为两种：</p><ul><li><strong>左值</strong> <em>(lvalue, left value)</em> 是能被取地址、不能被移动的值</li><li><strong>右值</strong> <em>(rvalue, right value)</em> 是表达式中间结果/函数返回值（可能拥有变量名，也可能没有）</li></ul><blockquote><p>C++ 17 细化了 <code>prvalue/xvalue/lvalue</code> 和 <code>rvalue/glvalue</code> 类别，本文不详细讨论。</p></blockquote><p><a href="https://en.cppreference.com/w/cpp/language/reference" target="_blank" rel="noopener"><strong>引用类型</strong> <em>(reference type)</em></a> 属于一种 <a href="https://en.cppreference.com/w/cpp/language/type" target="_blank" rel="noopener"><strong>变量类型</strong> <em>(variable type)</em></a>，将在 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#左值引用-vs-右值引用-vs-常引用" target="_blank" rel="noopener">§ 2.2</a> 详细讨论。</p><p>在变量 <a href="https://en.cppreference.com/w/cpp/language/initialization" target="_blank" rel="noopener"><strong>初始化</strong> <em>(initialization)</em></a> 时，需要将 <strong>初始值</strong> <em>(initial value)</em> 绑定到变量上；但 <a href="https://en.cppreference.com/w/cpp/language/reference_initialization" target="_blank" rel="noopener"><strong>引用类型变量</strong> 的初始化</a> 和其他的值类型（非引用类型）变量不同：</p><ul><li>创建时，<strong>必须显式初始化</strong>（和指针不同，不允许 <strong>空引用</strong> <em>(null reference)</em>；但可能存在 <strong>悬垂引用</strong> <em>(dangling reference)</em>）</li><li>相当于是 其引用的值 的一个 <strong>别名</strong> <em>(alias)</em>（例如，对引用变量的 <strong>赋值运算</strong> <em>(assignment operation)</em> 会赋值到 其引用的值 上）</li><li>一旦绑定了初始值，就 <strong>不能重新绑定</strong> 到其他值上了（和指针不同，赋值运算不能修改引用的指向；而对于 Java/JavaScript 等语言，对引用变量赋值 可以重新绑定）</li></ul><h4 id="左值引用-vs-右值引用-vs-常引用"><a href="#左值引用-vs-右值引用-vs-常引用" class="headerlink" title="左值引用 vs 右值引用 vs 常引用"></a>左值引用 vs 右值引用 vs 常引用</h4><p>引用类型 可以分为两种：</p><ul><li><strong>左值引用</strong> <em>(l-ref, lvalue reference)</em> 用 <code>&amp;</code> 符号引用 左值（但不能引用右值）</li><li><strong>右值引用</strong> <em>(r-ref, rvalue reference)</em> 用 <code>&amp;&amp;</code> 符号引用 右值（也可以移动左值）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Data&amp;  data)</span></span>;  <span class="comment">// 1, data is l-ref</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Data&amp;&amp; data)</span></span>;  <span class="comment">// 2, data is r-ref</span></span><br><span class="line">Data   data;</span><br><span class="line"></span><br><span class="line">Data&amp;  data1 = data;             <span class="comment">// OK</span></span><br><span class="line">Data&amp;  data1 = Data&#123;&#125;;           <span class="comment">// not compile: invalid binding</span></span><br><span class="line">Data&amp;&amp; data2 = Data&#123;&#125;;           <span class="comment">// OK</span></span><br><span class="line">Data&amp;&amp; data2 = data;             <span class="comment">// not compile: invalid binding</span></span><br><span class="line">Data&amp;&amp; data2 = <span class="built_in">std</span>::move(data);  <span class="comment">// OK</span></span><br><span class="line"></span><br><span class="line">f(data);    <span class="comment">// 1, data is lvalue</span></span><br><span class="line">f(Data&#123;&#125;);  <span class="comment">// 2, data is rvalue</span></span><br><span class="line">f(data1);   <span class="comment">// 1, data1 is l-ref type and lvalue</span></span><br><span class="line">f(data2);   <span class="comment">// 1, data2 is r-ref type but lvalue</span></span><br></pre></td></tr></table></figure><ul><li>左值引用变量 <code>data1</code> 在初始化时，不能绑定右值 <code>Data{}</code></li><li>右值引用变量 <code>data2</code> 在初始化时，不能绑定左值 <code>data</code>，但可以通过 <code>std::move()</code> 将左值 <strong>转为右值引用</strong>（参考 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#移动转发" target="_blank" rel="noopener">§ 5.4</a>）</li><li><strong>右值引用</strong> 变量 <code>data2</code> 被初始化后，在作用域内是 <strong>左值</strong>（参考 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#误解-不移动右值引用参数" target="_blank" rel="noopener">§ 1.4</a>），所以匹配 <code>f()</code> 的 <strong>重载 2</strong></li></ul><p>另外，C++ 还支持了 <strong>常引用</strong> <em>(c-ref, const reference)</em>，<strong>同时接受</strong> 左值/右值 进行初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(<span class="keyword">const</span> Data&amp; data)</span></span>;  <span class="comment">// data is c-ref</span></span><br><span class="line"></span><br><span class="line">g(data);    <span class="comment">// ok, data is lvalue</span></span><br><span class="line">g(Data&#123;&#125;);  <span class="comment">// ok, data is rvalue</span></span><br></pre></td></tr></table></figure><p>常引用和右值引用 都能接受右值的绑定，有什么区别呢？</p><ul><li>通过 右值引用/常引用 初始化的右值，都可以将 <a href="https://en.cppreference.com/w/cpp/language/reference_initialization#Lifetime_of_a_temporary" target="_blank" rel="noopener"><strong>生命周期扩展</strong> <em>(lifetime extension)</em></a> 到 绑定该右值的 引用的生命周期</li><li>初始化时 绑定了右值后，右值引用 <strong>可以修改</strong> 引用的右值，而 常引用 不能修改</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Data&amp; data1 = Data&#123;&#125;;   <span class="comment">// OK: extend lifetime</span></span><br><span class="line">data1.modify();               <span class="comment">// not compile: const</span></span><br><span class="line"></span><br><span class="line">Data&amp;&amp; data2 = Data&#123;&#125;;        <span class="comment">// OK: extend lifetime</span></span><br><span class="line">data2.modify();               <span class="comment">// OK: non-const</span></span><br></pre></td></tr></table></figure><h4 id="引用参数重载优先级"><a href="#引用参数重载优先级" class="headerlink" title="引用参数重载优先级"></a>引用参数重载优先级</h4><p>如果函数重载同时接受 右值引用/常引用 参数，编译器 <strong>优先重载</strong> 右值引用参数 —— 是 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#移动语义" target="_blank" rel="noopener">§ 3</a> 移动语义 的实现基础：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> Data&amp; data)</span></span>;  <span class="comment">// 1, data is c-ref</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(Data&amp;&amp; data)</span></span>;       <span class="comment">// 2, data is r-ref</span></span><br><span class="line"></span><br><span class="line">f(Data&#123;&#125;);  <span class="comment">// 2, prefer 2 over 1 for rvalue</span></span><br></pre></td></tr></table></figure><p>针对不同左右值 <strong>实参</strong> <em>(argument)</em> 重载 引用类型 <strong>形参</strong> <em>(parameter)</em> 的优先级如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">实参/形参</th><th style="text-align:center">T&amp;</th><th style="text-align:center">const T&amp;</th><th style="text-align:center">T&amp;&amp;</th><th style="text-align:center">const T&amp;&amp;</th></tr></thead><tbody><tr><td style="text-align:center">lvalue</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">const lvalue</td><td style="text-align:center"></td><td style="text-align:center">1</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">rvalue</td><td style="text-align:center"></td><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">2</td></tr><tr><td style="text-align:center">const rvalue</td><td style="text-align:center"></td><td style="text-align:center">2</td><td style="text-align:center"></td><td style="text-align:center">1</td></tr></tbody></table></div><ul><li>数值越小，优先级越高；如果不存在，则重载失败</li><li>如果同时存在 <strong>传值</strong> <em>(by value)</em> 重载（接受值类型参数 <code>T</code>），会和上述 <strong>传引用</strong> <em>(by reference)</em> 重载产生歧义，编译失败</li><li><strong>常右值引用</strong> <em>(const rvalue reference)</em> <code>const T&amp;&amp;</code> 一般不直接使用（<a href="https://codesynthesis.com/~boris/blog/2012/07/24/const-rvalue-references/" target="_blank" rel="noopener">参考</a>）</li></ul><h4 id="引用折叠"><a href="#引用折叠" class="headerlink" title="引用折叠"></a>引用折叠</h4><p><a href="https://en.cppreference.com/w/cpp/language/reference#Reference_collapsing" target="_blank" rel="noopener"><strong>引用折叠</strong> <em>(reference collapsing)</em></a> 是 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#移动转发" target="_blank" rel="noopener">§ 5.4</a> <code>std::move()</code> 和 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#完美转发" target="_blank" rel="noopener">§ 5.3</a> <code>std::forward()</code> 的实现基础：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> Lref = Data&amp;;</span><br><span class="line"><span class="keyword">using</span> Rref = Data&amp;&amp;;</span><br><span class="line">Data data;</span><br><span class="line"></span><br><span class="line">Lref&amp;  r1 = data;    <span class="comment">// r1 is Data&amp;</span></span><br><span class="line">Lref&amp;&amp; r2 = data;    <span class="comment">// r2 is Data&amp;</span></span><br><span class="line">Rref&amp;  r3 = data;    <span class="comment">// r3 is Data&amp;</span></span><br><span class="line">Rref&amp;&amp; r4 = Data&#123;&#125;;  <span class="comment">// r4 is Data&amp;&amp;</span></span><br></pre></td></tr></table></figure><h3 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h3><p>在 C++ 11 强化了左右值概念后，提出了 <strong>移动语义</strong> <em>(move semantic)</em> 优化：由于右值对象一般是临时对象，在移动时，对象包含的资源 <strong>不需要先拷贝再删除</strong>，只需要直接 <strong>从旧对象移动到新对象</strong>。</p><p>同时，要求 <strong>被移动的对象</strong> 处于 <strong>合法但未指定状态</strong>（参考 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#误解-被移动的值不能再使用" target="_blank" rel="noopener">§ 1.2</a>）：</p><ul><li>（基本要求）能正确析构（不会重复释放已经被移动了的资源，例如 <code>std::unique_ptr::~unique_ptr()</code> 检查指针是否需要 <code>delete</code>）</li><li>（一般要求）重新赋值后，和新的对象没有差别（C++ 标准库基于这个假设）</li><li>（更高要求）恢复为默认值（例如 <code>std::unique_ptr</code> 恢复为 <code>nullptr</code>）</li></ul><p>由于<strong>基本类型不包含资源，其移动和拷贝相同：被移动后，保持为原有值</strong>。</p><h4 id="避免先拷贝再释放资源"><a href="#避免先拷贝再释放资源" class="headerlink" title="避免先拷贝再释放资源"></a>避免先拷贝再释放资源</h4><p>一般通过 <strong>重载构造/赋值函数</strong> 实现移动语义。例如，<code>std::vector</code> 有：</p><ul><li>以常引用作为参数的 <strong>拷贝构造函数</strong> <em>(copy constructor)</em></li><li>以右值引用作为参数的 <strong>移动构造函数</strong> <em>(move constructor)</em></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">vector</span>(<span class="keyword">const</span> <span class="built_in">vector</span>&amp; rhs);      <span class="comment">// copy data</span></span><br><span class="line">  <span class="built_in">vector</span>(<span class="built_in">vector</span>&amp;&amp; rhs) <span class="keyword">noexcept</span>;  <span class="comment">// move data</span></span><br><span class="line">  ~<span class="built_in">vector</span>();                      <span class="comment">// dtor</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  T* data_ = <span class="literal">nullptr</span>;</span><br><span class="line">  <span class="keyword">size_t</span> size_ = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>::<span class="built_in">vector</span>(<span class="keyword">const</span> <span class="built_in">vector</span>&amp; rhs) : data_(<span class="keyword">new</span> T[rhs.size_]) &#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;lhs = *<span class="keyword">this</span>;</span><br><span class="line">  lhs.size_ = rhs.size_;</span><br><span class="line">  <span class="built_in">std</span>::copy_n(rhs.data_, rhs.size_, lhs.data_);  <span class="comment">// copy data</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>::<span class="built_in">vector</span>(<span class="built_in">vector</span>&amp;&amp; rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;lhs = *<span class="keyword">this</span>;</span><br><span class="line">  lhs.size_ = rhs.size_;</span><br><span class="line">  lhs.data_ = rhs.data_;  <span class="comment">// move data</span></span><br><span class="line">  rhs.size_ = <span class="number">0</span>;</span><br><span class="line">  rhs.data_ = <span class="literal">nullptr</span>;    <span class="comment">// set data of rhs to null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>::~<span class="built_in">vector</span>() &#123;</span><br><span class="line">  <span class="keyword">if</span> (data_)              <span class="comment">// release only if owned</span></span><br><span class="line">    <span class="keyword">delete</span>[] data_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，构造函数 <code>vector::vector()</code> 根据实参判断（重载优先级参考 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#引用参数重载优先级" target="_blank" rel="noopener">§ 2.3</a>）：</p><ul><li>实参为左值时，拷贝构造，使用 <code>new[]</code>/<code>std::copy_n</code> 拷贝原对象的所有元素（本方案有一次冗余的默认构造，仅用于演示）。</li><li>实参为右值时，移动构造，把指向原对象内存的指针 <code>data_</code>、内存大小 <code>size_</code> 拷贝到新对象，并把原对象这两个成员置 <code>0</code>。</li></ul><p>析构函数 <code>vector::~vector()</code> 检查 data_ 是否有效，决定是否需要释放资源。</p><blockquote><p>此处省略 拷贝赋值/移动赋值 函数，但建议加上。（参考 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#误解-手写错误的移动构造函数" target="_blank" rel="noopener">§ 1.5</a>）</p></blockquote><p>此外，<strong>类的成员函数</strong> 还可以通过 <a href="https://en.cppreference.com/w/cpp/language/member_functions#const-.2C_volatile-.2C_and_ref-qualified_member_functions" target="_blank" rel="noopener"><strong>引用限定符</strong> <em>(reference qualifier)</em></a>，针对当前对象本身的左右值状态（以及 const-volatile）重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Data <span class="title">data</span><span class="params">()</span> &amp;&amp; </span>&#123; <span class="keyword">return</span> <span class="built_in">std</span>::move(data_); &#125;  <span class="comment">// rvalue, move-out</span></span><br><span class="line">  <span class="function">Data <span class="title">data</span><span class="params">()</span> <span class="keyword">const</span>&amp; </span>&#123; <span class="keyword">return</span> data_; &#125;         <span class="comment">// otherwise, copy</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> ret1 = foo.data();    <span class="comment">// foo   is lvalue, copy</span></span><br><span class="line"><span class="keyword">auto</span> ret2 = Foo&#123;&#125;.data();  <span class="comment">// Foo&#123;&#125; is rvalue, move</span></span><br></pre></td></tr></table></figure><h4 id="转移不可拷贝的资源"><a href="#转移不可拷贝的资源" class="headerlink" title="转移不可拷贝的资源"></a>转移不可拷贝的资源</h4><blockquote><p>在之前写的 <a href="https://bot-man-jl.github.io/articles/?post=2018/Resource-Management#资源和对象的映射关系" target="_blank" rel="noopener">资源管理小记</a> 提到：如果资源是 <strong>不可拷贝</strong> <em>(non-copyable)</em> 的，那么装载资源的对象也应该是不可拷贝的。</p></blockquote><p>如果资源对象不可拷贝，一般需要定义 移动构造/移动赋值 函数，并禁用 拷贝构造/拷贝赋值 函数。例如，智能指针 <code>std::unique_ptr</code> <strong>只能移动</strong> <em>(move only)</em>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unique_ptr</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">unique_ptr</span>(<span class="keyword">const</span> <span class="built_in">unique_ptr</span>&amp; rhs) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="built_in">unique_ptr</span>(<span class="built_in">unique_ptr</span>&amp;&amp; rhs) <span class="keyword">noexcept</span>;  <span class="comment">// move only</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  T* data_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">unique_ptr</span>::<span class="built_in">unique_ptr</span>(<span class="built_in">unique_ptr</span>&amp;&amp; rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;lhs = *<span class="keyword">this</span>;</span><br><span class="line">  lhs.data_ = rhs.data_;</span><br><span class="line">  rhs.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，<code>unique_ptr</code> 的移动构造过程和 <code>vector</code> 类似：</p><ul><li>把指向原对象内存的指针 <code>data_</code> 拷贝到新对象</li><li>把原对象的指针 <code>data_</code> 置为空</li></ul><h4 id="反例：不遵守移动语义"><a href="#反例：不遵守移动语义" class="headerlink" title="反例：不遵守移动语义"></a>反例：不遵守移动语义</h4><p>移动语义只是语言上的一个 <strong>概念</strong>，具体是否移动对象的资源、如何移动对象的资源，都需要通过编写代码 <strong>实现</strong>。而移动语义常常被 <strong>误认为</strong>，编译器 <strong>自动生成</strong> 移动对象本身的代码（<a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#拷贝省略" target="_blank" rel="noopener">§ 4</a> 拷贝省略）。</p><p>为了证明这一点，我们可以实现不遵守移动语义的 <code>bad_vec::bad_vec(bad_vec&amp;&amp; rhs)</code>，执行拷贝语义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bad_vec::bad_vec(bad_vec&amp;&amp; rhs) : data_(<span class="keyword">new</span> T[rhs.size_]) &#123;</span><br><span class="line">  <span class="keyword">auto</span> &amp;lhs = *<span class="keyword">this</span>;</span><br><span class="line">  lhs.size_ = rhs.size_;</span><br><span class="line">  <span class="built_in">std</span>::copy_n(rhs.data_, rhs.size_, lhs.data_);  <span class="comment">// copy data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，一个 <code>bad_vec</code> 对象在被 <code>move</code> 移动后仍然可用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bad_vec&lt;<span class="keyword">int</span>&gt; v_old &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line"><span class="keyword">auto</span> v_new = <span class="built_in">std</span>::move(v_old);</span><br><span class="line"></span><br><span class="line">v_old[<span class="number">0</span>] = v_new[<span class="number">3</span>];           <span class="comment">// ok, but odd :-)</span></span><br><span class="line">assert(v_old[<span class="number">0</span>] != v_new[<span class="number">0</span>]);</span><br><span class="line">assert(v_old[<span class="number">0</span>] == v_new[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure><p>虽然代码可以那么写，但是在语义上有问题：进行了拷贝操作，违背了移动语义的初衷。</p><h3 id="拷贝省略"><a href="#拷贝省略" class="headerlink" title="拷贝省略"></a>拷贝省略</h3><p>尽管 C++ 引入了移动语义，移动的过程 仍有优化的空间 —— 与其调用一次 没有意义的移动构造函数，不如让编译器 直接跳过这个过程 —— 于是就有了 <a href="https://en.cppreference.com/w/cpp/language/copy_elision" target="_blank" rel="noopener">拷贝省略 <em>(copy elision)</em></a>。</p><p>然而，很多人会把移动语义和拷贝省略 <strong>混淆</strong>：</p><ul><li>移动语义是 <strong>语言标准</strong> 提出的概念，通过编写遵守移动语义的 移动构造函数、右值限定成员函数，<strong>逻辑上</strong> 优化 <strong>对象内资源</strong> 的转移流程</li><li>拷贝省略是（C++ 17 前）非标准的 <strong>编译器优化</strong>，跳过移动/拷贝构造函数，让编译器直接在 <strong>移动后的对象</strong> 内存上，构造 <strong>被移动的对象</strong>（例如 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#误解-移动非引用返回值" target="_blank" rel="noopener">§ 1.3</a> 的代码，直接在 函数返回值对象 的内存上，构造 函数局部对象 <code>ret</code> —— 在 <strong>不同作用域</strong> 里，共享 <strong>同一块内存</strong>）</li></ul><p>C++ 17 要求编译器对 <strong>纯右值</strong> <em>(prvalue, pure rvalue)</em> 进行拷贝省略优化。（<a href="https://jonasdevlieghere.com/guaranteed-copy-elision/" target="_blank" rel="noopener">参考</a>）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Data <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Data val;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">throw</span> val;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> val;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// NRVO from lvalue to ret (not guaranteed)</span></span><br><span class="line">  <span class="comment">// if NRVO is disabled, move ctor is called</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(Date arg)</span></span>;</span><br><span class="line"></span><br><span class="line">Data v = f();     <span class="comment">// copy elision from prvalue (C++ 17)</span></span><br><span class="line">g(f());           <span class="comment">// copy elision from prvalue (C++ 17)</span></span><br></pre></td></tr></table></figure><p>初始化 局部变量、函数参数时，传入的纯右值可以确保被优化 —— Return Value Optimization <em>(RVO)</em>；而返回的 <strong>将亡值</strong> <em>(xvalue, eXpiring value)</em> 不保证被优化 —— Named Return Value Optimization <em>(NRVO)</em>。</p><h3 id="通用引用和完美转发"><a href="#通用引用和完美转发" class="headerlink" title="通用引用和完美转发"></a>通用引用和完美转发</h3><blockquote><p>揭示 <code>std::move()</code>/<code>std::forward()</code> 的原理，需要读者有一定的 <strong>模板编程基础</strong>。</p></blockquote><h4 id="为什么需要通用引用"><a href="#为什么需要通用引用" class="headerlink" title="为什么需要通用引用"></a>为什么需要通用引用</h4><p>C++ 11 引入了变长模板的概念，允许向模板参数里传入不同类型的不定长引用参数。由于每个类型可能是左值引用或右值引用，针对所有可能的左右值引用组合，<strong>特化所有模板</strong> 是 <strong>不现实的</strong>。</p><p><strong>假设没有</strong> 通用引用的概念，模板 <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr/make_unique" target="_blank" rel="noopener"><code>std::make_unique&lt;&gt;</code></a> 至少需要两个重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;T&gt; make_unique(<span class="keyword">const</span> Args&amp;... args) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">new</span> T &#123; args... &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;T&gt; make_unique(Args&amp;&amp;... args) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">new</span> T &#123; <span class="built_in">std</span>::move&lt;Args&gt;(args)... &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于传入的左值引用 <code>const Args&amp;... args</code>，只要展开 <code>args...</code> 就可以转发这一组左值引用</li><li>对于传入的右值引用 <code>Args&amp;&amp;... args</code>，需要通过 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#移动转发" target="_blank" rel="noopener">§ 5.4</a> <code>std::move()</code> 转发出去，即 <code>std::move(args)...</code>（为什么要转发：参考 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#误解-不移动右值引用参数" target="_blank" rel="noopener">§ 1.4</a>）</li></ul><p>上述代码的问题在于：如果传入的 <code>args</code> <strong>既有</strong> 左值引用 <strong>又有</strong> 右值引用，那么这两个模板都 <strong>无法匹配</strong>。</p><h4 id="通用引用"><a href="#通用引用" class="headerlink" title="通用引用"></a>通用引用</h4><blockquote><p>Item 24: Distinguish universal references from rvalue references. —— Scott Meyers, <em>Effective Modern C++</em></p></blockquote><p><a href="https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers" target="_blank" rel="noopener">Scott Meyers 指出</a>：有时候符号 <code>&amp;&amp;</code> 并不一定代表右值引用，它也可能是左值引用 —— 如果一个引用符号需要通过 左右值类型推导（模板参数类型 或 <code>auto</code> 推导），那么这个符号可能是左值引用或右值引用 —— 这叫做 <strong>通用引用</strong> <em>(universal reference)</em>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// rvalue ref: no type deduction</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(Widget&amp;&amp; param1)</span></span>;</span><br><span class="line">Widget&amp;&amp; var1 = Widget();</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="built_in">vector</span>&lt;T&gt;&amp;&amp; param2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// universal ref: type deduction</span></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br></pre></td></tr></table></figure><p>上述代码中，前三个 <code>&amp;&amp;</code> 符号不涉及引用符号的左右值类型推导，都是右值引用；而后两个 <code>&amp;&amp;</code> 符号会 <strong>根据初始值推导左右值类型</strong>：</p><ul><li>对于 <code>var2</code>，因为 <code>var1</code> 是左值，所以 <code>var2</code> 也是左值引用<ul><li>推导不会参考 <code>var1</code> 的变量类型</li></ul></li><li>对于 <code>T&amp;&amp;</code>：<ul><li>如果 <code>param</code> 传入左值，<code>T&amp;&amp;</code> 是左值引用 <code>std::remove_reference_t&amp;</code></li><li>如果 <code>param</code> 传入右值，<code>T&amp;&amp;</code> 是右值引用 <code>std::remove_reference_t&amp;&amp;</code></li></ul></li></ul><p>基于通用引用，<a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#为什么需要通用引用" target="_blank" rel="noopener">§ 5.1</a> 的模板 <code>std::make_unique&lt;&gt;</code> 只需要一个重载：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;T&gt; make_unique(Args&amp;&amp;... args) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">new</span> T &#123; <span class="built_in">std</span>::forward&lt;Args&gt;(args)... &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>std::forward()</code> 实现了 <strong>针对不同左右值参数的转发</strong> —— 完美转发。</p><blockquote><p>这里就是完美转发真正的意义所在，会将形参的引用类型转发出去。</p></blockquote><h4 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h4><p>什么是 <strong>完美转发</strong> <em>(perfect forwarding)</em>：</p><ul><li>如果参数是 <strong>左值引用</strong>，直接以 <strong>左值引用</strong> 的形式，转发给下一个函数</li><li>如果参数是 <strong>右值引用</strong>，要先 “还原” 为 <strong>右值引用</strong> 的形式，再转发给下一个函数</li></ul><p>因此，<a href="https://en.cppreference.com/w/cpp/utility/forward" target="_blank" rel="noopener"><code>std::forward()</code></a> 定义两个 <strong>不涉及</strong> 左右值类型 <strong>推导</strong> 的模板（不能使用 通用引用参数）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">remove_reference_t</span>&lt;T&gt;&amp; val)</span> <span class="keyword">noexcept</span> </span>&#123;  <span class="comment">// #1</span></span><br><span class="line">  <span class="comment">// forward lvalue as either lvalue or rvalue</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T&amp;&amp; <span class="title">forward</span><span class="params">(<span class="built_in">std</span>::<span class="keyword">remove_reference_t</span>&lt;T&gt;&amp;&amp; val)</span> <span class="keyword">noexcept</span> </span>&#123;  <span class="comment">// #2</span></span><br><span class="line">  <span class="comment">// forward rvalue as rvalue (not lvalue)</span></span><br><span class="line">  <span class="keyword">static_assert</span>(!<span class="built_in">std</span>::is_lvalue_reference_v&lt;T&gt;,</span><br><span class="line">                <span class="string">"Cannot forward rvalue as lvalue."</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T&amp;&amp;&gt;(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">实参/返回值</th><th style="text-align:center">重载</th><th style="text-align:center">l-ref 返回值</th><th style="text-align:center">r-ref 返回值</th></tr></thead><tbody><tr><td style="text-align:center">l-ref 实参</td><td style="text-align:center">#1</td><td style="text-align:center">完美转发</td><td style="text-align:center"><strong>移动转发</strong></td></tr><tr><td style="text-align:center">r-ref 实参</td><td style="text-align:center">#2</td><td style="text-align:center"><strong>语义错误</strong></td><td style="text-align:center">完美转发</td></tr></tbody></table></div><ul><li>尽管初始化后的变量都是 <strong>左值</strong>（参考 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#误解-不移动右值引用参数" target="_blank" rel="noopener">§ 1.4</a>），但原始的 <strong>变量类型</strong> 仍会保留</li><li>因此，可以根据 <strong>实参类型</strong> 选择重载，<strong>和模板参数 <code>T</code> 的类型无关</strong></li><li><strong>返回值类型</strong> <code>static_cast(val)</code> 经过模板参数 <code>T&amp;&amp;</code> <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#引用折叠" target="_blank" rel="noopener">§ 2.4</a> 引用折叠 实现 完美转发/移动转发，<strong>和实参类型无关</strong></li><li>“将 l-ref 实参 转发为 r-ref 返回值” 等价于 <a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference#移动转发" target="_blank" rel="noopener">§ 5.4</a> <code>std::move()</code> 移动转发</li></ul><h4 id="移动转发"><a href="#移动转发" class="headerlink" title="移动转发"></a>移动转发</h4><p>类似的，<a href="https://en.cppreference.com/w/cpp/utility/move" target="_blank" rel="noopener"><code>std::move()</code></a> 只转发为右值引用类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::<span class="keyword">remove_reference_t</span>&lt;T&gt;&amp;&amp; move(T&amp;&amp; val) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">  <span class="comment">// forward either lvalue or rvalue as rvalue</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="built_in">std</span>::<span class="keyword">remove_reference_t</span>&lt;T&gt;&amp;&amp;&gt;(val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:center">实参/返回值</th><th style="text-align:center">r-ref 返回值</th></tr></thead><tbody><tr><td style="text-align:center">l-ref 实参</td><td style="text-align:center">移动转发</td></tr><tr><td style="text-align:center">r-ref 实参</td><td style="text-align:center">移动转发（完美转发）</td></tr></tbody></table></div><ul><li>接受 通用引用模板参数 <code>T&amp;&amp;</code>（无需两个模板，使用时不区分 <code>T</code> 的引用类型）</li><li>返回值 <code>static_cast&amp;&amp;&gt;(val)</code> 将实参 <strong>转为将亡值</strong>（右值引用类型）</li><li>所以 <code>std::move()</code> 等价于 <code>std::forward&amp;&amp;&gt;()</code></li></ul><p>最后，<code>std::move()</code>/<code>std::forward()</code> 只是编译时的变量类型转换，不会产生目标代码。</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul><li>原文链接：<a href="https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference" target="_blank" rel="noopener">https://bot-man-jl.github.io/articles/?post=2018/Cpp-Rvalue-Reference</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一篇关于 C++11 右值引用的一篇总结，觉得其中对于常见误用的总结很不错，想起来了当年自己走过的一些坑，转载做个记录。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://murphypei.github.io/categories/C-C/"/>
    
    
      <category term="C++11" scheme="https://murphypei.github.io/tags/C-11/"/>
    
      <category term="右值引用" scheme="https://murphypei.github.io/tags/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8/"/>
    
      <category term="移动" scheme="https://murphypei.github.io/tags/%E7%A7%BB%E5%8A%A8/"/>
    
      <category term="完美转发" scheme="https://murphypei.github.io/tags/%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>C++11 thread_local 用法</title>
    <link href="https://murphypei.github.io//blog/2020/02/thread-local.html"/>
    <id>https://murphypei.github.io//blog/2020/02/thread-local.html</id>
    <published>2020-02-21T05:34:19.000Z</published>
    <updated>2020-04-12T04:18:10.812Z</updated>
    
    <content type="html"><![CDATA[<p>thread_local 是 C++11 为线程安全引进的变量声明符。</p><a id="more"></a><h3 id="thread-local-简介"><a href="#thread-local-简介" class="headerlink" title="thread_local 简介"></a>thread_local 简介</h3><p>thread_local 是一个<a href="https://zh.cppreference.com/w/cpp/language/storage_duration" target="_blank" rel="noopener">存储器指定符</a>。</p><blockquote><p>所谓存储器指定符，其作用类似命名空间，指定了变量名的存储期以及链接方式。同类型的关键字还有：</p><ul><li>auto：自动存储期；</li><li>register：自动存储期，提示编译器将此变量置于寄存器中；</li><li>static：静态或线程存储期，同时提示是内部链接；</li><li>extern：静态或线程存储期，同时提示是外部链接；</li><li>thread_local：线程存储期；</li><li>mutable：不影响存储期或链接。</li></ul></blockquote><p>对于 thread_local，官方解释是：</p><blockquote><p><em>thread_local</em> 关键词只对声明于命名空间作用域的对象、声明于块作用域的对象及静态数据成员允许。它指示对象拥有线程存储期。它能与 static 或 extern 结合，以分别指定内部或外部链接（除了静态数据成员始终拥有外部链接），但<strong>附加的 static 不影响存储期</strong>。</p><p><strong>线程存储期</strong>: 对象的存储在线程开始时分配，而在线程结束时解分配。每个线程拥有其自身的对象实例。唯有声明为 thread_local 的对象拥有此存储期。 thread_local 能与 static 或 extern 一同出现，以调整链接。</p></blockquote><p>这里有一个很重要的信息，就是 <strong><code>static thread_local</code> 和 <code>thread_local</code> 声明是等价的</strong>，都是指定变量的周期是在线程内部，并且是静态的。这是什么意思呢？举个代码的例子。</p><p>下面是一个线程安全的均匀分布随机数生成，例子来源于 <a href="https://stackoverflow.com/questions/21237905/how-do-i-generate-thread-safe-uniform-random-numbers" target="_blank" rel="noopener">stackoverflow</a>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">random_uniform_float</span><span class="params">(<span class="keyword">float</span> *<span class="keyword">const</span> dst, <span class="keyword">const</span> <span class="keyword">int</span> len, <span class="keyword">const</span> <span class="keyword">int</span> min = <span class="number">0</span>, <span class="keyword">const</span> <span class="keyword">int</span> max = <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// generator is only created once in per thread, but distribution can be regenerated.</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">thread_local</span> <span class="built_in">std</span>::default_random_engine generator;     <span class="comment">// heavy</span></span><br><span class="line">    <span class="built_in">std</span>::uniform_real_distribution&lt;<span class="keyword">float</span>&gt; distribution(min, max); <span class="comment">// light</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dst[i] = distribution(generator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>generator</code> 是一个函数的静态变量，理论上这个静态变量在函数的所有调用期间都是同一个的（静态存储期），相反 <code>distribution</code> 是每次调用生成的函数内临时变量。现在 <code>generator</code> 被 thread_local 修饰，表示其存储周期从整个函数调用变为了线程存储期，也就是在同一个线程内，这个变量表现的就和函数静态变量一样，但是不同线程中是不同的。可以理解为 thread_local 缩小了变量的存储周期。关于 thread_local 变量自动 static，C++ 标准中也有说明：</p><blockquote><p>When thread_local is applied to a variable of block scope the storage-class-specifier static <strong>is implied</strong> if it does not appear explicitly</p></blockquote><p>关于 thread_local 的定义我也不想过多着墨，还是看代码例子说明吧。</p><h3 id="thread-local-使用示例"><a href="#thread-local-使用示例" class="headerlink" title="thread_local 使用示例"></a>thread_local 使用示例</h3><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::mutex cout_mutex;    <span class="comment">//方便多线程打印</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; thread_name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        x++;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(cout_mutex);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread["</span> &lt;&lt; thread_name &lt;&lt; <span class="string">"]: x = "</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(thread_func, <span class="string">"t1"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(thread_func, <span class="string">"t2"</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread[t2]: x = 2</span><br><span class="line">thread[t2]: x = 3</span><br><span class="line">thread[t2]: x = 4</span><br><span class="line">thread[t1]: x = 2</span><br><span class="line">thread[t1]: x = 3</span><br><span class="line">thread[t1]: x = 4</span><br></pre></td></tr></table></figure><p><strong>可以看出全局的 thread_local 变量在每个线程里是分别自加互不干扰的。</strong></p><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::mutex cout_mutex;    <span class="comment">//方便多线程打印</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; thread_name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">thread_local</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">        x++;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(cout_mutex);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread["</span> &lt;&lt; thread_name &lt;&lt; <span class="string">"]: x = "</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(thread_func, <span class="string">"t1"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(thread_func, <span class="string">"t2"</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread[t2]: x = 2</span><br><span class="line">thread[t2]: x = 3</span><br><span class="line">thread[t2]: x = 4</span><br><span class="line">thread[t1]: x = 2</span><br><span class="line">thread[t1]: x = 3</span><br><span class="line">thread[t1]: x = 4</span><br></pre></td></tr></table></figure><p>可以看到虽然是局部变量，但是在每个线程的每次 for 循环中，使用的都是线程中的同一个变量，也侧面印证了 <strong>thread_local 变量会自动 static</strong>。</p><p>如果我们不加 thread_local，输出如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thread[t2]: x = <span class="number">2</span></span><br><span class="line">thread[t2]: x = <span class="number">2</span></span><br><span class="line">thread[t2]: x = <span class="number">2</span></span><br><span class="line">thread[t1]: x = <span class="number">2</span></span><br><span class="line">thread[t1]: x = <span class="number">2</span></span><br><span class="line">thread[t1]: x = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>体现了局部变量的特征。</p><p>这里还有一个要注意的地方，就是 <strong>thread_local 虽然改变了变量的存储周期，但是并没有改变变量的使用周期或者说作用域</strong>，比如上述的局部变量，其使用范围不能超过 for 循环外部，否则编译出错。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; thread_name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">thread_local</span> <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">        x++;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(cout_mutex);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread["</span> &lt;&lt; thread_name &lt;&lt; <span class="string">"]: x = "</span> &lt;&lt; x &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x++;    <span class="comment">//编译会出错：error: ‘x’ was not declared in this scope</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类对象"><a href="#类对象" class="headerlink" title="类对象"></a>类对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="built_in">std</span>::mutex cout_mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    A() &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(cout_mutex);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"create A"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~A() &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(cout_mutex);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"destroy A"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> counter++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; thread_name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">thread_local</span> A* a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(cout_mutex);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread["</span> &lt;&lt; thread_name &lt;&lt; <span class="string">"]: a.counter:"</span> &lt;&lt; a-&gt;get_value() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(thread_func, <span class="string">"t1"</span>)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(thread_func, <span class="string">"t2"</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create A</span><br><span class="line">thread[t1]: a.counter:<span class="number">0</span></span><br><span class="line">thread[t1]: a.counter:<span class="number">1</span></span><br><span class="line">thread[t1]: a.counter:<span class="number">2</span></span><br><span class="line">create A</span><br><span class="line">thread[t2]: a.counter:<span class="number">0</span></span><br><span class="line">thread[t2]: a.counter:<span class="number">1</span></span><br><span class="line">thread[t2]: a.counter:<span class="number">2</span></span><br></pre></td></tr></table></figure><p>可以看出类对象的使用和创建和内部类型类似，都不会创建多个。这种情况在函数间或通过函数返回实例也是一样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">A* <span class="title">creatA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loopin_func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; thread_name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">thread_local</span> A* a = creatA();</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(cout_mutex);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread["</span> &lt;&lt; thread_name &lt;&lt; <span class="string">"]: a.counter:"</span> &lt;&lt; a-&gt;get_value() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; thread_name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;    </span><br><span class="line">        loopin_func(thread_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create A</span><br><span class="line">thread[t1]: a.counter:0</span><br><span class="line">thread[t1]: a.counter:1</span><br><span class="line">thread[t1]: a.counter:2</span><br><span class="line">create A</span><br><span class="line">thread[t2]: a.counter:0</span><br><span class="line">thread[t2]: a.counter:1</span><br><span class="line">thread[t2]: a.counter:2</span><br></pre></td></tr></table></figure><p>虽然 <code>createA()</code> 看上去被调用了多次，实际上只被调用了一次，因为 thread_local 变量只会在每个<strong>线程最开始被调用的时候进行初始化，并且只会被初始化一次</strong>。</p><p>举一反三，如果不是初始化，而是赋值，则情况就不同了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void loopin_func(const std::string&amp; thread_name) &#123;</span><br><span class="line">    thread_local A* a;</span><br><span class="line">    a = creatA();</span><br><span class="line">    std::lock_guard&lt;std::mutex&gt; lock(cout_mutex);</span><br><span class="line">    std::cout &lt;&lt; &quot;thread[&quot; &lt;&lt; thread_name &lt;&lt; &quot;]: a.counter:&quot; &lt;&lt; a-&gt;get_value() &lt;&lt; std::endl;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">create A</span><br><span class="line">thread[t1]: a.counter:<span class="number">0</span></span><br><span class="line">thread[t1]: a.counter:<span class="number">1</span></span><br><span class="line">thread[t1]: a.counter:<span class="number">2</span></span><br><span class="line">create A</span><br><span class="line">thread[t2]: a.counter:<span class="number">0</span></span><br><span class="line">thread[t2]: a.counter:<span class="number">1</span></span><br><span class="line">thread[t2]: a.counter:<span class="number">2</span></span><br></pre></td></tr></table></figure><p>很明显，虽然只初始化一次，但却可以被多次赋值，因此 C++ 变量初始化是十分重要的（手动狗头）。</p><h4 id="类成员变量"><a href="#类成员变量" class="headerlink" title="类成员变量"></a>类成员变量</h4><p>规定：<strong>thread_local 作为类成员变量时必须是 static 的</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    B() &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(cout_mutex);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"create B"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~B() &#123;&#125;</span><br><span class="line">    <span class="keyword">thread_local</span> <span class="keyword">static</span> <span class="keyword">int</span> b_key;</span><br><span class="line">    <span class="comment">//thread_local int b_key;</span></span><br><span class="line">    <span class="keyword">int</span> b_value = <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b_static;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">thread_local</span> <span class="keyword">int</span> B::b_key = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span> B::b_static = <span class="number">36</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; thread_name)</span> </span>&#123;</span><br><span class="line">    B b;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        b.b_key--;</span><br><span class="line">        b.b_value--;</span><br><span class="line">        b.b_static--;   <span class="comment">// not thread safe</span></span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(cout_mutex);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread["</span> &lt;&lt; thread_name &lt;&lt; <span class="string">"]: b_key:"</span> &lt;&lt; b.b_key &lt;&lt; <span class="string">", b_value:"</span> &lt;&lt; b.b_value &lt;&lt; <span class="string">", b_static:"</span> &lt;&lt; b.b_static &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread["</span> &lt;&lt; thread_name &lt;&lt; <span class="string">"]: B::key:"</span> &lt;&lt; B::b_key &lt;&lt; <span class="string">", b_value:"</span> &lt;&lt; b.b_value &lt;&lt; <span class="string">", b_static: "</span> &lt;&lt; B::b_static &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">create B</span><br><span class="line">thread[t2]: b_key:11, b_value:23, b_static:35</span><br><span class="line">thread[t2]: B::key:11, b_value:23, b_static: 35</span><br><span class="line">thread[t2]: b_key:10, b_value:22, b_static:34</span><br><span class="line">thread[t2]: B::key:10, b_value:22, b_static: 34</span><br><span class="line">thread[t2]: b_key:9, b_value:21, b_static:33</span><br><span class="line">thread[t2]: B::key:9, b_value:21, b_static: 33</span><br><span class="line">create B</span><br><span class="line">thread[t1]: b_key:11, b_value:23, b_static:32</span><br><span class="line">thread[t1]: B::key:11, b_value:23, b_static: 32</span><br><span class="line">thread[t1]: b_key:10, b_value:22, b_static:31</span><br><span class="line">thread[t1]: B::key:10, b_value:22, b_static: 31</span><br><span class="line">thread[t1]: b_key:9, b_value:21, b_static:30</span><br><span class="line">thread[t1]: B::key:9, b_value:21, b_static: 30</span><br></pre></td></tr></table></figure><p><code>b_key</code> 是 thread_local，虽然其也是 static 的，但是每个线程中有一个，每次线程中的所有调用共享这个变量。<code>b_static</code> 是真正的 static，全局只有一个，所有线程共享这个变量。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://zh.cppreference.com/w/cpp/language/storage_duration" target="_blank" rel="noopener">https://zh.cppreference.com/w/cpp/language/storage_duration</a></li><li><a href="https://stackoverflow.com/questions/21237905/how-do-i-generate-thread-safe-uniform-random-numbers" target="_blank" rel="noopener">https://stackoverflow.com/questions/21237905/how-do-i-generate-thread-safe-uniform-random-numbers</a></li><li><a href="http://cifangyiquan.net/programming/thread_local/" target="_blank" rel="noopener">http://cifangyiquan.net/programming/thread_local/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;thread_local 是 C++11 为线程安全引进的变量声明符。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://murphypei.github.io/categories/C-C/"/>
    
    
      <category term="C++" scheme="https://murphypei.github.io/tags/C/"/>
    
      <category term="thread" scheme="https://murphypei.github.io/tags/thread/"/>
    
      <category term="static" scheme="https://murphypei.github.io/tags/static/"/>
    
      <category term="thread_local" scheme="https://murphypei.github.io/tags/thread-local/"/>
    
  </entry>
  
  <entry>
    <title>Linux下shadowsocks使用配置</title>
    <link href="https://murphypei.github.io//blog/2020/02/linux-shadowsocks-config.html"/>
    <id>https://murphypei.github.io//blog/2020/02/linux-shadowsocks-config.html</id>
    <published>2020-02-10T03:43:08.000Z</published>
    <updated>2020-03-26T08:19:37.637Z</updated>
    
    <content type="html"><![CDATA[<p>记录 Linux 使用 shadowsocks 的方法。</p><a id="more"></a><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install shadowsocks</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>创建配置文件： <code>/etc/shadowsocks.json</code></p><p>内容如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "server":"1.2.3.4", // 服务器IP</span><br><span class="line">    "server_port":8888, // 对外提供服务的端口</span><br><span class="line">    "local_port":1080,</span><br><span class="line">    "password":"your password",</span><br><span class="line">    "timeout":600,</span><br><span class="line">    "method":"aes-256-cfb",</span><br><span class="line">    "fast-open": true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="作为服务器"><a href="#作为服务器" class="headerlink" title="作为服务器"></a>作为服务器</h4><p>前台启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json</span><br></pre></td></tr></table></figure><p>后台运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssserver -c /etc/shadowsocks.json -d start # 启动</span><br><span class="line">ssserver -c /etc/shadowsocks.json -d stop # 停止</span><br></pre></td></tr></table></figure><h4 id="作为客户端"><a href="#作为客户端" class="headerlink" title="作为客户端"></a>作为客户端</h4><p>前台启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sslocal -c /etc/shadowsocks.json</span><br></pre></td></tr></table></figure><p>后台运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sslocal -c /etc/shadowsocks.json -d start # 启动</span><br><span class="line">sslocal -c /etc/shadowsocks.json -d stop # 停止</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录 Linux 使用 shadowsocks 的方法。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://murphypei.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://murphypei.github.io/tags/Linux/"/>
    
      <category term="shadowsocks" scheme="https://murphypei.github.io/tags/shadowsocks/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu 启动过程中各配置脚本执行顺序</title>
    <link href="https://murphypei.github.io//blog/2020/02/linux-startup-scripts.html"/>
    <id>https://murphypei.github.io//blog/2020/02/linux-startup-scripts.html</id>
    <published>2020-02-10T02:58:25.000Z</published>
    <updated>2020-03-26T08:19:37.640Z</updated>
    
    <content type="html"><![CDATA[<p>登录 Linux 时，会有 <code>/etc/profile</code>、<code>~/.bash_profile</code>、<code>~/.bashrc</code>等相关配置文件依次启动，本文以 Ubuntu 为例说明。</p><a id="more"></a><p>对于 Ubuntu 而言，系统登录时会读取 <code>/etc/profile</code> 的内容。</p><p>在 <code>/etc/profile</code> 文件中会启动 <code>/etc/bash.bashrc</code>，然后遍历 <code>/etc/profile.d</code> 文件夹，启动里面的每一个 sh 文件。</p><p>然后执行 <code>~/.bash_profile</code> 或者 <code>~/.bash_login</code> 或者 <code>~/.profile</code> 中的一个，他们的执行优先级为 bash_profile&gt;bash_login&gt;profile。</p><p>当我们在终端打开一个 shell（包括打开一个新终端和在终端上输入bash），都会重新读取和 <code>~/.bashrc</code> 文件里面的内容。</p><p>使用 login 和 non login 术语来说，就是使用 login 方式是会读取 <code>/etc/profile</code> 和 <code>~/.profile</code> 文件。使用 non login 方式的话，会读取 <code>/etc/bash.bashrc</code> 和 <code>~/.bashrc</code> 文件的内容。也就是说 <code>/etc/profile</code> 和 <code>~/.profile</code> 文件是在 login 时才会读取。所以，在不使用 su 命令的情况下，只有在 Linux 启动登录的时候才会被读取（这也就导致了有些软件安装后，要重启才能生效）。</p><blockquote><p>login 模式是指用户通过 /bin/login 登录进系统然后启动 shell，而 non login 模式是指由某些程序启动的 shell，比如 /bin/bash。</p></blockquote><p>在退出登录时会执行 <code>~/.bash_logout</code>。</p><p>因此各脚本执行顺序为：<code>/etc/profile</code> -&gt; (<code>~/.bash_profile</code> | <code>~/.bash_login</code> | <code>~/.profile</code>) -&gt; <code>~/.bashrc</code> -&gt; <code>~/.bash_logout</code>。</p><p>关于各个文件的作用域，在网上找到了以下说明：</p><ul><li><code>/etc/profile</code>： 此文件为系统的每个用户设置环境信息，当用户第一次登录时，该文件被执行，<strong>该文件仅仅执行一次</strong>。并从 <code>/etc/profile.d</code> 目录的配置文件中搜集 shell 的设置。</li><li><code>/etc/bash.bashrc</code>：为每一个运行 bash shell 的用户执行此文件.当 bash shell 被打开时，该文件被读取。</li><li><code>~/.bash_profile</code>：每个用户都可使用该文件输入专用于自己使用的 shell 信息，当用户登录时，<strong>该文件仅仅执行一次</strong>。默认情况下，他设置一些环境变量，执行用户的 .bashrc 文件。</li><li><code>~/.bashrc</code>：该文件包含专用于你的 bash shell 的 bash 信息，当登录时以及每次打开新的 shell 时，该该文件被读取。</li><li><code>~/.bash_logout</code>：当每次退出系统(退出bash shell)时，执行该文件。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;登录 Linux 时，会有 &lt;code&gt;/etc/profile&lt;/code&gt;、&lt;code&gt;~/.bash_profile&lt;/code&gt;、&lt;code&gt;~/.bashrc&lt;/code&gt;等相关配置文件依次启动，本文以 Ubuntu 为例说明。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://murphypei.github.io/categories/Linux/"/>
    
    
      <category term="Ubuntu， Linux， bashrc， profile， bash_profile" scheme="https://murphypei.github.io/tags/Ubuntu%EF%BC%8C-Linux%EF%BC%8C-bashrc%EF%BC%8C-profile%EF%BC%8C-bash-profile/"/>
    
  </entry>
  
  <entry>
    <title>Assert 在 Debug 和 Release 引起的问题</title>
    <link href="https://murphypei.github.io//blog/2020/01/assert-debug-release.html"/>
    <id>https://murphypei.github.io//blog/2020/01/assert-debug-release.html</id>
    <published>2020-01-17T08:56:49.000Z</published>
    <updated>2020-04-12T04:18:10.812Z</updated>
    
    <content type="html"><![CDATA[<p>在一次代码调试过程中，发现 Debug 和 Release 的结果不一致，由此引发的问题追溯…</p><a id="more"></a><p>因为 Debug 和 Release 不同，程序并没有报错，所以很容易想到是不是编译器做了什么操作导致编译的代码产生区别。</p><p>说实话，这次调试的过程是非常痛苦的，完全找不到头绪，最后通过一步步代码回退发现是 assert 的调用导致了问题。大概原理如下：</p><p>假设在一个循环中重复调用函数 <code>do_something</code>。这个函数在成功的情况下返回 0，失败则返回非 0 值。但是你完全不期望它在程序中<br>出现失败的情况。你可能会想这样写：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line">  assert (do_something () == <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>不过，你可能发现这个运行时检查引入了不可承受的性能损失，并因此决定稍候指定 NDEBUG 以禁用运行时检测（Release 编译就等同于此）。这样做的结果是整个对 assert 的调用会被完全删除，也就是说，assert 宏的条件表达式将永远不会被执行，<code>do_something</code> 一次也不会被调用。因此，<strong>这样写才是正确的</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i) &#123;</span><br><span class="line">  <span class="keyword">int</span> status = do_something ();</span><br><span class="line">  assert (status == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一步查询发现，在 <code>&lt;cassert&gt;</code> 头文件中，assert 的定义为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> assert(condition) ((void)0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> assert(condition) <span class="comment">/*implementation defined*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>也就是说 <code>assert</code> 语句在 Release 模式下是失效的…虽然程序继续运行了，但是结果不对。</p><p>这个问题弄了好久，但是说到底还是学艺不精，吃一堑长一智吧，记住 assert 的调用正确的写法，不过也可以牺牲部分性能定义一个检查的宏来代替 assert 的检查。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在一次代码调试过程中，发现 Debug 和 Release 的结果不一致，由此引发的问题追溯…&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://murphypei.github.io/categories/C-C/"/>
    
    
      <category term="C++" scheme="https://murphypei.github.io/tags/C/"/>
    
      <category term="debug" scheme="https://murphypei.github.io/tags/debug/"/>
    
      <category term="assert" scheme="https://murphypei.github.io/tags/assert/"/>
    
      <category term="断言" scheme="https://murphypei.github.io/tags/%E6%96%AD%E8%A8%80/"/>
    
      <category term="宏" scheme="https://murphypei.github.io/tags/%E5%AE%8F/"/>
    
  </entry>
  
  <entry>
    <title>Git-LFS 使用和迁移</title>
    <link href="https://murphypei.github.io//blog/2019/12/git-lfs.html"/>
    <id>https://murphypei.github.io//blog/2019/12/git-lfs.html</id>
    <published>2019-12-23T12:39:50.000Z</published>
    <updated>2020-04-12T04:20:18.961Z</updated>
    
    <content type="html"><![CDATA[<p>一次 Git-LFS 的迁移记录。</p><a id="more"></a><p>网上说了一大堆 Git-LFS 的作用和好处，我觉得都是把官方文档零零碎碎翻译一下。在我看来，对于普通开发者而言，Git-LFS 的作用很简单，就是让你 <strong>pull 代码的时候不用每次都把一大堆大文件一块 pull 下来</strong>，而且我个人使用体验还有切换分支之类的操作都变快了。</p><h3 id="Git-LFS-安装"><a href="#Git-LFS-安装" class="headerlink" title="Git-LFS 安装"></a>Git-LFS 安装</h3><p><code>sudo apt/yum install git-lfs</code> 即可，然后 <code>git lfs install</code>。</p><h3 id="Git-LFS-使用"><a href="#Git-LFS-使用" class="headerlink" title="Git-LFS 使用"></a>Git-LFS 使用</h3><h4 id="追踪和推送"><a href="#追踪和推送" class="headerlink" title="追踪和推送"></a>追踪和推送</h4><p>在一个已经初始化后的 Git 仓库中使用 Git-LFS 来追踪大文件，命令如下：</p><p><code>git lfs track &lt;filepattern&gt;</code></p><p>track 会产生一个 <code>.gitattributes</code> 文件，和 <code>.gitignore</code> 类似，也是 git 自己的文件，用于描述 Git-LFS 的文件名匹配模板。一般而言，文件中的每一行类似这种：</p><p><code>*.pbtxt filter=lfs diff=lfs merge=lfs -text</code></p><p><code>-text</code> 就是表示这个文件<strong>不是文本文件</strong>。其余的就是告诉 Git 在处理 filter、diff、merge 时将 pbtxt 文件通过 LFS 的方式处理，打开 <code>.gitconfig</code> 可以看到相关命令的替换。</p><p>用 Git-LFS track 追踪档案之后，就可以添加、提交和推送到远端目录上，你在首次推上去的时候，会要一些时间将大型档案传输到远端。这里是很多教程很模糊的地方，事实上，Git-LFS 并不是什么魔法，仍然要将文件同步到远端。有的 git 仓库页面会显示 Git-LFS 的标记，gitlab 就可以，好评，tx 自用的工蜂，呵呵。</p><h4 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h4><p>其他用户使用这个仓库的时候，使用 <code>git clone</code> 会拉取普通的文件，但是 LFS 追踪的文件不会被拉下来。如果这些文件本地没有，则需要使用 <code>git lfs pull</code> 从远程仓库拉取。</p><blockquote><p>现在的 git 貌似是直接能够拉取所有文件，包括 lfs 文件，如果不想拉取 lfs 文件，可以使用 <code>GIT_LFS_SKIP_SMUDGE=1 git clone</code></p></blockquote><p>总结来看，Git-LFS 唯一的目的就是于其他 clone 使用者来说，他们若不需要异动大型档案，就不需要进行git lfs pull 的动作，于是那个原本的大型档案会变成一个130 bytes 的文字档。即使他clone 整个master，也是很小的储存库。Git-LFS 的使用无关档案大小，唯一的重点在于某些档案你想放在 master 内，或是说必须放在master 内，而其他人又不需要同步这个档案的话，就可以使用 Git-LFS 的方式来管理此档案。</p><h3 id="Git-LFS-迁移"><a href="#Git-LFS-迁移" class="headerlink" title="Git-LFS  迁移"></a>Git-LFS  迁移</h3><p>这个才是比较实用的，因为很多仓库是用着用着才想着用 lfs…</p><p>对于一个已经用了一段时间的 Git 仓库，直接执行  <code>git lfs migrate import --include=&quot;*.bin&quot; --everything</code> ，可以将所有本地分支上的匹配文件的提交历史版本都转换为 lfs，这个时候无论你切换到哪个分支，都会出现 <code>.gitattributes</code> 文件，且内容都是一样的。</p><blockquote><p>如果只想更新某个分支的话，可以使用 <code>git lfs migrate import --include=&quot;*.bin&quot; --include-ref=refs/heads/master</code></p></blockquote><p>可以通过 <code>git lfs ls-files</code> 查看哪些文件被转换成 lfs 了。</p><p>切换成功后，就需要把切换之后的本地分支提交到远程仓库了，需要手动 push 更新远程仓库中的各个分支。这里有个极大需要注意的地方，就是转换会更改所有提交的 hash，因此 push 的时候需要使用 force 选项，而当其他人员再次使用 pull 去远程拉取的时候会失败。这里当然可以使用 <code>pull --allow-unrelated-histories</code> 来把远程仓库被修改的历史与本地仓库历史做合并，但是最好是<strong>重新拉取</strong>。</p><p>切换成功后，git 仓库的大小可能并没有变化，主要是之前的提交还在，因此需要做一些清理工作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reflog expire --expire-unreachable=now --all</span><br><span class="line">git gc --prune=now</span><br></pre></td></tr></table></figure><p>但是，<strong>如果不是历史记录非常重要的仓库，建议不要像上述这么做，而是重新建立一个新的仓库。个人经验，迁移可以使用，但并没那么美好</strong>。</p><p>附一个迁移相关的<a href="https://github.com/Git-LFS/Git-LFS/wiki/Tutorial" target="_blank" rel="noopener">基础教程</a></p><h3 id="Git-LFS-需要多次输入密码的问题"><a href="#Git-LFS-需要多次输入密码的问题" class="headerlink" title="Git-LFS 需要多次输入密码的问题"></a>Git-LFS 需要多次输入密码的问题</h3><p>解决 Git-LFS 使用导致 push 需要输入多次用户名和密码。</p><p>Linux：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Set git to use the credential memory cache</span></span><br><span class="line">git config --global credential.helper cache</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the cache to timeout after 1 hour (setting is in seconds)</span></span><br><span class="line">git config --global credential.helper <span class="string">'cache --timeout=3600'</span></span><br></pre></td></tr></table></figure><p>其他平台可以参考：<a href="https://help.github.com/en/github/using-git/caching-your-github-password-in-git" target="_blank" rel="noopener">Caching your GitHub password in Git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一次 Git-LFS 的迁移记录。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://murphypei.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://murphypei.github.io/tags/Git/"/>
    
      <category term="LFS" scheme="https://murphypei.github.io/tags/LFS/"/>
    
      <category term="migrate" scheme="https://murphypei.github.io/tags/migrate/"/>
    
      <category term=".gitattributes" scheme="https://murphypei.github.io/tags/gitattributes/"/>
    
  </entry>
  
  <entry>
    <title>聊聊梯度消失和梯度爆炸</title>
    <link href="https://murphypei.github.io//blog/2019/12/sigmoid-gradient.html"/>
    <id>https://murphypei.github.io//blog/2019/12/sigmoid-gradient.html</id>
    <published>2019-12-23T06:33:54.000Z</published>
    <updated>2020-04-12T04:20:10.961Z</updated>
    
    <content type="html"><![CDATA[<p>周末刷知乎看到一个问题，关于如何理解梯度消失和梯度爆炸的。有个回答讲的比较好，就和 sigmoid 函数一起总结一下吧。</p><a id="more"></a><h3 id="梯度消失和爆炸"><a href="#梯度消失和爆炸" class="headerlink" title="梯度消失和爆炸"></a>梯度消失和爆炸</h3><p>梯度消失和梯度爆炸本质就是<strong>激活函数（的导数）和权重相互作用产生的联合效果</strong>，这个很重要，因为很多人以为梯度消失和爆炸是只存在某些激活函数中，其实不然。梯度消失和爆炸不单单是激活函数的问题， 不管你用 sigmoid/tanh 还是 ReLU 都有可能发生梯度消失/爆炸，只是发生的频繁程度不同。</p><p>我们知道，神经网络的每层计算可以看重矩阵相乘之后接一个非线性映射也就是激活函数，可以表示为：</p><script type="math/tex; mode=display">h_{t+1}= \sigma (Wh_t)</script><p>求导以后就是：</p><script type="math/tex; mode=display">\frac {\partial h_{t+1}} {\partial ht}=diag(\sigma'(Wh_t))W</script><p>其中等式右边第一项是对角阵，表示激活函数的导函数，假如<strong>激活函数是 sigmoid 函数，则对角阵中每个元素都小于 1</strong> ，会产生压缩的效果；而第二项特征值的大小与 W 本身有关，既可能收缩也可能扩张。</p><p>假如 W 的所有特征值都小于 1，那么此时两项相乘也是收缩的效果；反之，两项的乘积有可能（注意不是一定）产生扩张的效果。多层累积以后，就有可能发生梯度消失和梯度爆炸。 因为 sigmoid 函数的导数值域小于 1，所以很依赖 W 的值，因此容易产生梯度消失，tanh 同理。但是并不是说一定会梯度消失。如果使用的激活函数的导数值域大于 1，则容易产生梯度爆炸，但是不一定会。ReLU 梯度等于 1，看上去比较合适。</p><h3 id="sigmoid-求导"><a href="#sigmoid-求导" class="headerlink" title="sigmoid 求导"></a>sigmoid 求导</h3><p>为什么 sigmoid 函数的导数小于 1 呢？求导就明白了。</p><p>sigmoid 函数：</p><script type="math/tex; mode=display">f(x) = \frac {1}{1 + e^{-x}}= (1 + e^{-x})^{-1}</script><p>求导：</p><script type="math/tex; mode=display">\begin {align}f'(x) &= (-1) (1 + e^{-x})^{-2}e^{-x}(-1) \\&= (1+e^{-x})^{-2}e^{-x} \\&= \frac {e^{-x}} {(1+e^{-x})^2} \\&= \frac {1+e^{-x}-1} {(1+e^{-x})^2} \\&= \frac {1+e^{-x}} {(1+e^{-x})^2} -  \frac {1} {(1+e^{-x})^2} \\&= \frac {1+e^{-x}} {(1+e^{-x})^2} -  \frac {1} {(1+e^{-x})^2} \\&= \frac {1} {1+e^{-x}} -  \frac {1} {(1+e^{-x})^2} \\&= f(x) - (f(x))^2\end {align}</script><p>因为 sigmoid 函数的值域： $0 &lt; f(x) &lt; 1$ ，因此 $0 &lt; f’(x) &lt; 1$。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;周末刷知乎看到一个问题，关于如何理解梯度消失和梯度爆炸的。有个回答讲的比较好，就和 sigmoid 函数一起总结一下吧。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://murphypei.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://murphypei.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="sigmoid" scheme="https://murphypei.github.io/tags/sigmoid/"/>
    
      <category term="梯度消失" scheme="https://murphypei.github.io/tags/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1/"/>
    
      <category term="梯度爆炸" scheme="https://murphypei.github.io/tags/%E6%A2%AF%E5%BA%A6%E7%88%86%E7%82%B8/"/>
    
  </entry>
  
  <entry>
    <title>PCA 数学原理总结</title>
    <link href="https://murphypei.github.io//blog/2019/12/pca-repost.html"/>
    <id>https://murphypei.github.io//blog/2019/12/pca-repost.html</id>
    <published>2019-12-09T02:59:54.000Z</published>
    <updated>2020-04-12T04:20:23.996Z</updated>
    
    <content type="html"><![CDATA[<p>PCA（Principal Component Analysis） 是一种常见的数据分析方式，常用于高维数据的降维，可用于提取数据的主要特征分量。我之前也写过一篇简单的 PCA 的数学理解，日前看到<a href="https://zhuanlan.zhihu.com/p/77151308" target="_blank" rel="noopener">一篇文章</a>讲解的很棒，就整理转载过来，作为以后复习的总结。</p><a id="more"></a><p>理解 PCA，我觉得从其数学推导入手是非常好的途径。PCA 的数学推导可以从最大可分型和最近重构性两方面进行，前者的优化条件为划分后方差最大，后者的优化条件为点到划分平面距离最小，这里我将从最大可分性的角度进行证明。</p><h3 id="特征表示和降维"><a href="#特征表示和降维" class="headerlink" title="特征表示和降维"></a>特征表示和降维</h3><p>在机器学习任务中，一般用一个特征向量描述一个样本，每个样本都有很多维特征，在机器学习中，一条样本由一个<strong>列向量</strong>表示。但是对于样本而言，某些特征之间有线性关系甚至直接关系。</p><p>举个例子，假如某学籍数据有两列 M 和 F，其中 M 列的取值是如何此学生为男性取值 1，为女性取值 0；而 F 列是学生为女性取值 1，男性取值 0。此时如果我们统计全部学籍数据，会发现对于任何一条记录来说，当 M 为 1 时 F 必定为 0，反之当 M 为 0 时 F 必定为 1。在这种情况下，我们将 M 或 F 去掉实际上没有任何信息的损失，因为只要保留一列就可以完全还原另一列。</p><p>当然上面是一个极端的情况，在现实中也许不会出现，不过类似的情况还是很常见的。例如上面淘宝店铺的数据，从经验我们可以知道，“浏览量”和“访客数”往往具有较强的相关关系，而“下单数”和“成交数”也具有较强的相关关系。这里我们非正式的使用“相关关系”这个词，可以直观理解为“当某一天这个店铺的浏览量较高（或较低）时，我们应该很大程度上认为这天的访客数也较高（或较低）”。这种情况表明，如果我们删除浏览量或访客数其中一个指标，我们应该期待并不会丢失太多信息。因此我们可以删除一个，以降低机器学习算法的复杂度。</p><p>上面这些让我们能够隐约感觉到特征之间的相关性，这些特征就可以去重。另一方面，对于样本个数比较少但是特征非常丰富的训练样本，少量样本在高维特征空间中就变成了稀疏分布，模型拟合就比较发散，而且计算量增加，通过降维把高维空间的特征映射到低维空间中，也就是降低特征的维度，可以减少计算量，加快模型拟合。以上就是降维的朴素思想描述和动机。</p><h3 id="向量内积"><a href="#向量内积" class="headerlink" title="向量内积"></a>向量内积</h3><p>文章首先介绍了关于向量内积的知识，这里不再对这些基础进行总结了。只需要记住：<strong>设向量 B 的模为 1，向量 A 与 B 的内积值等于 A 向 B 所在直线投影的矢量长度</strong>。这就是内积的一种几何解释，也是我们得到的第一个重要结论。</p><h3 id="基"><a href="#基" class="headerlink" title="基"></a>基</h3><p>向量的基（也称基向量）用于描述一个多维空间。在多维空间中，如果我们<strong>要准确描述向量，首先要确定一组基，然后给出在基所在的各个直线上的投影值，就可以了</strong>。关于多维空间的基，这里也不啰嗦了，线性代数基础知识，但是需要记住一个重要结论，也是我一直比较推崇的，理解关于矩阵相乘的物理解释：<strong>两个矩阵相乘的意义是将右边矩阵中的 <em>每一列</em> 向量 $a_i$ 变换到左边矩阵中以 <em>每一行</em> 向量为基所表示的空间中去</strong>。</p><p>这里也解释了为什么一个样本数据要用一个列向量来表示，因为这个列向量通过矩阵相乘的形式被变换到其他特征空间（特征维度可能不一样）中，就可以得到这个样本在另一个特征空间的描述了。</p><h3 id="最大可分性"><a href="#最大可分性" class="headerlink" title="最大可分性"></a>最大可分性</h3><p>描述一个多维空间中的某一向量，<strong>选择不同的基可以对同样一组数据给出不同的表示</strong>，如果基的数量少于向量本身的维数，则可以达到降维的效果。</p><blockquote><p>这里说的向量本身的维度其实也是数据的一种描述方式，比如如果一条数据的向量维度是13，则表示这条数据用13个基来描述，第 i 个特征值是该数据在第 i 个基上的投影长度。我们用 PCA 降维就是找到另一种用更少的基描述数据的方式。</p></blockquote><p>但是我们还没回答一个最关键的问题：如何选择基才是最优的。或者说，如果我们有一组 N 维向量，现在要将其降到 K 维（K 小于 N），那么我们应该如何选择 K 个基才能最大程度保留原有的信息？一种直观的看法是：希望投影后的投影值尽可能分散，因为如果重叠就会有样本消失。当然这个也可以从熵的角度进行理解，熵越大所含信息越多，这就是最大可分性的出发点。</p><h4 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h4><p>方差用于描述一组数组的分散程度，变量的方差可以看做是每个元素与变量均值的差的平方和的均值，即：</p><script type="math/tex; mode=display">Var(a) = \frac {1}{m} \sum_{i=1}^{m}(a_i-\mu)^2</script><p>为了方便处理，我们将每个变量的均值都化为 0 ，因此方差可以直接用每个元素的平方和除以元素个数表示：</p><script type="math/tex; mode=display">Var(a) = \frac {1}{m} \sum_{i=1}^{m}(a_i)^2</script><p>于是上面的如何判断分散问题被形式化表述为：<strong>寻找一个一维基，使得所有数据变换为这个基上的坐标表示后，方差值最大。</strong></p><h4 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h4><p>在一维空间中我们可以用方差来表示数据的分散程度。而对于高维数据，我们用协方差进行约束，协方差可以表示两个变量的相关性。为了让两个变量尽可能表示更多的原始信息，我们希望它们之间不存在线性相关性，因为相关性意味着两个变量不是完全独立，必然存在重复表示的信息。</p><p>协方差公式为：</p><script type="math/tex; mode=display">Cov(a,b)=\frac {1} {m-1} \sum_{i=1}^{m}(a_i-\mu_a)(b_i-\mu_b)</script><p>因为均值为 0，因此：</p><script type="math/tex; mode=display">Cov(a,b)=\frac {1} {m} \sum_{i=1}^{m}a_ib_i</script><blockquote><p>当样本数较大时，不必在意其是 m 还是 m-1，为了方便计算，我们分母取 m。</p></blockquote><p>当协方差为 0 时，表示两个变量完全独立。为了让协方差为 0，我们选择第二个基时只能在与第一个基正交的方向上进行选择，因此最终选择的两个方向一定是正交的。</p><p>至此，我们得到了降维问题的优化目标：<strong>将一组 N 维向量降为 K 维，其目标是选择 K 个单位正交基，使得原始数据变换到这组基上后，各变量两两间协方差为 0，而变量方差则尽可能大（在正交的约束下，取最大的 K 个方差）。</strong></p><blockquote><p>这里的变量不是指某条数据，而是一个表示特征的基向量。因此 PCA 降维的目标就是找 K 个正交基（向量内积为 0 则正交）。</p></blockquote><h4 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h4><p>针对我们给出的优化目标，接下来我们将从数学的角度来给出优化目标。</p><p>我们看到，最终要达到的目的与<strong>变量内方差及变量间协方差</strong>有密切关系。因此我们希望能将两者统一表示，仔细观察发现，两者均可以表示为内积的形式，而内积又与矩阵相乘密切相关。</p><p>假设我们只有 a 和 b 两个变量，有 m 个样本，那么我们将它们组成矩阵 X：</p><script type="math/tex; mode=display">X=\begin{pmatrix}a_1 & a_2 & \cdots & a_m \\b_1 & b_2 & \cdots & b_m\end{pmatrix}</script><p>然后：</p><script type="math/tex; mode=display">\frac{1}{m} X X^T=\begin{pmatrix}\frac{1}{m}\sum_{i=1}^{m}a_{i}^{2} & \frac{1}{m}\sum_{i=1}^{m}a_ib_i  \\\frac{1}{m}\sum_{i=1}^{m}a_ib_i & \frac{1}{m}\sum_{i=1}^{m}b_{i}^{2}\end{pmatrix}=\begin{pmatrix}Cov(a,a) & Cov(a,b) \\Cov(b,a) & Cov(b,b) \\\end{pmatrix}</script><p>我们可以看到这个矩阵对角线上的分别是两个变量的方差，而其它元素是 a 和 b 的协方差。两者被统一到了一个矩阵里。</p><p>根据上述公式，我们很容易被推广到一般情况：</p><p><strong>设我们有 m 个 n 维数据记录，将其排列成矩阵 $X_{n,m}$，设 $C=\frac{1}{m}XX^T$ ，则 C 是一个对称矩阵，其对角线分别对应各个变量的方差，而第 i 行 j 列和 j 行 i 列元素相同，表示 i 和 j 两个维度特征的协方差</strong>。</p><h3 id="矩阵对角化"><a href="#矩阵对角化" class="headerlink" title="矩阵对角化"></a>矩阵对角化</h3><p>根据我们的优化条件，<strong>我们需要将除对角线外的其它元素化为 0（协方差为 0），并且在对角线上将元素按大小从上到下排列（方差尽可能大）</strong>，这样我们就达到了优化目的。这样说可能还不是很明晰，我们进一步看下原矩阵与基变换后矩阵协方差矩阵的关系。</p><p>设原始数据矩阵 X 对应的协方差矩阵为 C，而 P 是一组基按行组成的矩阵，设 Y=PX，则 Y 为 X 对 P 做基变换后的数据。设 Y 的协方差矩阵为 D，我们推导一下 D 与 C 的关系：</p><script type="math/tex; mode=display">\begin{align} D &= \frac{1}{m}YY^T \\ &= \frac{1}{m}(PX)(PX)^T \\ &= \frac{1}{m}PXX^TP^T \\ &= P(\frac{1}{m}XX^T)P^T \\ &= P(C)P^T \\\end{align}</script><p>这样我们就看清楚了，我们要找的 P 是能让原始协方差矩阵对角化的 P。换句话说，优化目标变成了<strong>寻找一个矩阵 P，满足 $PCP^T$ 是一个对角矩阵，并且对角元素按从大到小依次排列，那么 P 的前 K 行就是要寻找的基，用 P 的前 K 行组成的矩阵乘以 X 就使得 X 从 N 维降到了 K 维并满足上述优化条件</strong>。</p><p>至此，我们离 PCA 还有仅一步之遥，我们还需要完成对角化。</p><p>由上文知道，协方差矩阵 C 是一个是对称矩阵，在线性代数中实对称矩阵有一系列非常好的性质：</p><ol><li>实对称矩阵不同特征值对应的特征向量必然正交。</li><li>设特征向量 $\lambda$ 重数为 r，则必然存在 r 个线性无关的特征向量对应于 $\lambda$  ，因此可以将这 r 个特征向量单位正交化。</li></ol><p>由上面两条可知，一个 n 行 n 列的实对称矩阵一定可以找到 n 个单位正交特征向量，设这 n 个特征向量为：$e_1,e_2,\cdots,e_n$，我们将其按列组成矩阵：$E=(e_1,e_2,\cdots,e_n)$。</p><p>则对协方差矩阵 C，有如下结论：</p><script type="math/tex; mode=display">E^TCE=\Lambda =\begin{pmatrix} \lambda_1 &  &  & \\ &  \lambda_2 &  & \\ &  &  \cdots & \\ &  &  & \lambda_n\end{pmatrix}</script><p>其中 $\Lambda$ 为对角矩阵，其对角元素为各特征向量对应的特征值（可能有重复）。</p><p>到这里，我们发现我们已经找到了需要的矩阵 P：$P=E^T$。</p><p>P 是协方差矩阵的特征向量单位化后按行排列出的矩阵，其中每一行都是 C 的一个特征向量。如果设 P 按照 $\Lambda$  中特征值的从大到小，将特征向量从上到下排列，则用 P 的前 K 行组成的矩阵乘以原始数据矩阵 X，就得到了我们需要的降维后的数据矩阵 Y。</p><blockquote><p>原文还介绍基于拉格朗日乘子法的 PCA 数学推导，我这里就不展开了。</p></blockquote><h3 id="PCA-求解步骤"><a href="#PCA-求解步骤" class="headerlink" title="PCA 求解步骤"></a>PCA 求解步骤</h3><p>总结一下 PCA 的算法步骤：</p><p>设有 m 条 n 维数据：</p><ol><li>将原始数据按列组成 n 行 m 列矩阵 X；</li><li>将 X 的每一行进行零均值化，即减去这一行的均值；</li><li>求出协方差矩阵  $C=\frac {1}{m}XX^T$  ；</li><li>求出协方差矩阵的特征值及对应的特征向量；</li><li>将特征向量按对应特征值大小从上到下按行排列成矩阵，取前 K 行组成矩阵 P；</li><li>求得矩阵 $Y=PX$，即为降维到 K 维后的数据。</li></ol><h4 id="零均值化"><a href="#零均值化" class="headerlink" title="零均值化"></a>零均值化</h4><p>当对训练集进行 PCA 降维时，也需要对验证集、测试集执行同样的降维。而<strong>对验证集、测试集执行零均值化操作时，均值必须从训练集计算而来</strong>，不能使用验证集或者测试集的中心向量。</p><p>其原因也很简单，因为我们的训练集时可观测到的数据，测试集不可观测所以不会知道其均值，而验证集再大部分情况下是在处理完数据后再从训练集中分离出来，一般不会单独处理。如果真的是单独处理了，不能独自求均值的原因是和测试集一样。</p><p>另外我们也需要保证一致性，我们拿训练集训练出来的模型用来预测测试集的前提假设就是两者是独立同分布的，如果不能保证一致性的话，会出现 Variance Shift 的问题。</p><h3 id="PCA-的一些性质"><a href="#PCA-的一些性质" class="headerlink" title="PCA 的一些性质"></a>PCA 的一些性质</h3><ol><li><strong>缓解维度灾难</strong>：PCA 算法通过舍去一部分信息之后能使得样本的采样密度增大（因为维数降低了），这是缓解维度灾难的重要手段；</li><li><strong>降噪</strong>：当数据受到噪声影响时，最小特征值对应的特征向量往往与噪声有关，将它们舍弃能在一定程度上起到降噪的效果；</li><li><strong>过拟合</strong>：PCA 保留了主要信息，但这个主要信息只是针对训练集的，而且这个主要信息未必是重要信息。有可能舍弃了一些看似无用的信息，但是这些看似无用的信息恰好是重要信息，只是在训练集上没有很大的表现，所以 <strong>PCA 也可能加剧了过拟合</strong>；</li><li><strong>特征独立</strong>：PCA 不仅将数据压缩到低维，它也使得降维之后的数据各特征相互独立；</li></ol><h3 id="PCA-和-SVD-的对比"><a href="#PCA-和-SVD-的对比" class="headerlink" title="PCA 和 SVD 的对比"></a>PCA 和 SVD 的对比</h3><p>这是两个不同的数学定义。我们先给结论：<strong>特征值和特征向量是针对方阵</strong>才有的，而<strong>对任意形状的矩阵都可以做奇异值分解</strong>。</p><h4 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h4><p>方阵的特征值分解，对于一个方针 A，总可以写成：$A=Q \Lambda Q^{-1}$。其中，Q 是这个矩阵 A 的特征向量组成的矩阵，$\Lambda$ 是一个对角矩阵，每一个对角线元素就是一个特征值，里面的特征值是由小排列的，这些特征值所对应的特征向量就是描述这个矩阵变化方向（从主要的变化到次要的变化排列）。也就是说<strong>矩阵 A 的信息可以由其特征值和特征向量表示</strong>，这也是矩阵特征值和特征向量的重要物理意义之一。</p><h4 id="SVD"><a href="#SVD" class="headerlink" title="SVD"></a>SVD</h4><p>矩阵的奇异值分解其实就是对于矩阵 A 的协方差矩阵 $A^TA$ 和 $AA^T$ 做特征值分解推导出来的：</p><script type="math/tex; mode=display">A_{m,n}=U_{m,m} \Lambda_{m,n} V_{n,n}^{T} \approx U_{m,k} \Lambda_{k,k} V_{k,n}^{T}</script><p>其中：U 和 V 都是正交矩阵，有 $U^TU=I_m$，$V^TV=I_n$。这里的约等于是因为 $\Lambda$ 中有 n 个奇异值，但是由于排在后面的很多接近 0，所以我们可以仅保留比较大的 k 个奇异值。</p><script type="math/tex; mode=display">A^TA=(U \Lambda V^T)^T U \Lambda V^T=V \Lambda^TU^TU \Lambda V^T=V \Lambda^2V^T</script><script type="math/tex; mode=display">AA^T=U \Lambda V^T(U \Lambda V^T)^T =U \Lambda V^TV \Lambda^TU^T=U \Lambda^2U^T</script><p>所以，V U 两个矩阵分别是 $A^TA$ 和 $AA^T$ 的特征向量，中间的矩阵对角线的元素是 $A^TA$ 和 $AA^T$ 的特征值。我们也很容易看出 A 的奇异值和 $A^TA$  的特征值之间的关系。</p><p>PCA 需要对协方差矩阵 $C=\frac {1}{m} XX^T$ 进行特征值分解；SVD 也是对 $A^TA$ 进行特征值分解。如果取 $A=\frac{X^T}{\sqrt{m}}$ ，则二者基本等价。所以 PCA 问题可以转换成 SVD 求解。实际上 Sklearn 的 PCA 就是用 SVD 进行求解的，原因有以下几点：</p><ol><li>当样本维度很高时，协方差矩阵计算太慢；</li><li>方针特征值分解计算效率不高；</li><li>SVD 出了特征值分解这种求解方式外，还有更高效更准球的迭代求解方式，避免了 $A^TA$ 的计算；</li><li>其实 PCA 与 SVD 的右奇异向量的压缩效果相同。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PCA（Principal Component Analysis） 是一种常见的数据分析方式，常用于高维数据的降维，可用于提取数据的主要特征分量。我之前也写过一篇简单的 PCA 的数学理解，日前看到&lt;a href=&quot;https://zhuanlan.zhihu.com/p/77151308&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一篇文章&lt;/a&gt;讲解的很棒，就整理转载过来，作为以后复习的总结。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://murphypei.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://murphypei.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="PCA" scheme="https://murphypei.github.io/tags/PCA/"/>
    
      <category term="矩阵分解" scheme="https://murphypei.github.io/tags/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3/"/>
    
      <category term="协方差" scheme="https://murphypei.github.io/tags/%E5%8D%8F%E6%96%B9%E5%B7%AE/"/>
    
  </entry>
  
  <entry>
    <title>机器学习中关于熵的一些概念</title>
    <link href="https://murphypei.github.io//blog/2019/12/entropy.html"/>
    <id>https://murphypei.github.io//blog/2019/12/entropy.html</id>
    <published>2019-12-04T07:25:37.000Z</published>
    <updated>2020-03-26T08:19:37.620Z</updated>
    
    <content type="html"><![CDATA[<p>交叉熵是机器学习中常用的一个概念，一般用来衡量目标值与预测值之间的差距。熵的概念源于信息论，因此，首先从信息论角度进行分析。</p><a id="more"></a><h3 id="信息量"><a href="#信息量" class="headerlink" title="信息量"></a>信息量</h3><p>对于事件集合 $X$，其中一个随机发生的事件 $X=x_0$ 发生的概率是 $p(x_0)$，这个事件所包含的信息量为：</p><script type="math/tex; mode=display">I(x_0)-\log(p(x_0))</script><p>事件发生的概率越大，信息量越小，反之，概率越小，信息量越大。这也符合人们的直观感觉。</p><h3 id="信息熵"><a href="#信息熵" class="headerlink" title="信息熵"></a>信息熵</h3><p>在信息论与概率统计中，熵表示随机变量不确定性的度量。熵越大，表示不确定性越大。信息熵用来表示所有信息量的期望：</p><script type="math/tex; mode=display">H(X)=-\sum_{i=1}^{n}p(x_i)\log(p(x_i))</script><p>信息熵可以表示一个事件（变量）集合的不确定程度。</p><h3 id="联合熵"><a href="#联合熵" class="headerlink" title="联合熵"></a>联合熵</h3><p>假设要度量的对象不是单一变量的集合，而是一个联合分布的随即系统，这个系统的不确定程度可以用联合熵描述：</p><script type="math/tex; mode=display">H(X,Y)=-\sum_{x \in X} \sum_{y \in Y}p(x,y) \log p(x,y)</script><p>联合熵就是联合信息量的期望。</p><h3 id="条件熵"><a href="#条件熵" class="headerlink" title="条件熵"></a>条件熵</h3><p>如果联合分布中有一个条件已知，和概率论中条件概率类似，联合熵就变成了条件熵：</p><script type="math/tex; mode=display">H(Y|X)=-\sum_{x \in X} \sum_{y \in Y}p(x,y) \log p(y|x)</script><p>但是注意，条件熵这个定义其实是通过信息熵和联合熵推导出来的：</p><script type="math/tex; mode=display">\begin{align*}  H(X,Y) &= -\sum_{x \in X} \sum_{y \in Y}p(x,y) \log p(x,y) \\&= -\sum_{x \in X} \sum_{y \in Y}p(x,y) \log (p(x) \cdot p(y|x)) \\&= -\sum_{x \in X} \sum_{y \in Y}p(x,y) \log p(x) - \sum_{x \in X} \sum_{y \in Y}p(x,y) \log p(y|x) \\&= H(X)+H(Y|X)\end{align*}</script><p>条件熵公式表明，对拥有两个随机变量的随机系统，我们可以先观察一个随机变量获取信息量，观察完后，我们可以在拥有这个信息量的基础上观察第二个随机变量的信息量。并且我们可以很容易推导出，不论先观察谁，对信息量都不会有影响，这是非常符合直觉的。</p><p>以上联合熵和条件熵可以进一步推广到多个随机变量系统，根据链式法则可以很容易就推导出：</p><script type="math/tex; mode=display">H(X_1,X_2,\cdots ,X_n)=\sum_{i=1}^{n}H(X_i|X_{i-1},\cdots,X_1)</script><h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><p>信息增益是针对具体属性的，常用于机器学习决策树构建中的特征选择。指的是分类前的信息熵减去分类后的信息熵，即选用某个属性或者特征分类后，<strong>信息熵的减少量</strong>，计算如下：</p><script type="math/tex; mode=display">G(D,a)=H(D)-\sum_{v=1}^{V}\frac {|D^v|}{D}H(D^v)</script><p>$H(D)$ 为划分之前的信息熵，当根据特征 $a$ 分为 $V$ 类之后，每个子类别的信息熵为 $H(D^v)$，$\frac {|D^v|}{D}$ 表示子类别数目占总数目的比例。可以看出，等号右边的后半部分就是条件熵。</p><p>注意：$H(D)$ 和 $H(D^v)$ 均看作是一个随机变量集合，在内部按照实际的类别以及比例计算各自的信息熵。这里的计算一定要明白，不懂可以看《统计学习方法》的计算实例。</p><p>信息增益用于 ID3 决策树算法中。</p><h3 id="信息增益率"><a href="#信息增益率" class="headerlink" title="信息增益率"></a>信息增益率</h3><script type="math/tex; mode=display">G_R(D,a)=\frac {G(D,a)}{H(D)}</script><p>信息增益率用于 C4.5 决策树算法中。</p><h3 id="基尼系数"><a href="#基尼系数" class="headerlink" title="基尼系数"></a>基尼系数</h3><p>在分类问题中，假设有 $K$ 个类别，第 $k$ 个类别的概率为 $p_k$，则基尼系数的表达式为：</p><script type="math/tex; mode=display">G(p) = \sum\limits_{k=1}^{K}p_k(1-p_k) = 1- \sum\limits_{k=1}^{K}p_k^2</script><p>基尼系数用于 CART 决策树算法中。</p><h3 id="相对熵"><a href="#相对熵" class="headerlink" title="相对熵"></a>相对熵</h3><p>相对熵又称为KL散度，常用来度量两个分部的相似程度，计算公式：</p><script type="math/tex; mode=display">D_{KL}(p||q)=\sum_{i=1}^{n}p(x_i)\log(\frac {p(x_i)} {q(x_i)})</script><p>相对熵的值越小，表示一个新的分布 $q$ 和 原始分布 $p$ 越接近。相对熵用于 TensorRT 的量化校验。</p><h3 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h3><script type="math/tex; mode=display">H(p,q)=-\sum_{i=1}^{n}p(x_i)\log(q(x_i))</script><p>用于推导相对熵。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;交叉熵是机器学习中常用的一个概念，一般用来衡量目标值与预测值之间的差距。熵的概念源于信息论，因此，首先从信息论角度进行分析。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="https://murphypei.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="https://murphypei.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="熵" scheme="https://murphypei.github.io/tags/%E7%86%B5/"/>
    
      <category term="信息增益" scheme="https://murphypei.github.io/tags/%E4%BF%A1%E6%81%AF%E5%A2%9E%E7%9B%8A/"/>
    
      <category term="基尼系数" scheme="https://murphypei.github.io/tags/%E5%9F%BA%E5%B0%BC%E7%B3%BB%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>STL 中的二分查找</title>
    <link href="https://murphypei.github.io//blog/2019/11/stl-binary.html"/>
    <id>https://murphypei.github.io//blog/2019/11/stl-binary.html</id>
    <published>2019-11-29T03:27:44.000Z</published>
    <updated>2020-04-12T04:18:10.812Z</updated>
    
    <content type="html"><![CDATA[<p>STL 中的算法都很精妙，有很多实现值得我们细究和学习。</p><a id="more"></a><p>STL 容器中有两个有趣的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个非递减序列[first, last)中的第一个大于等于值val的位置。</span></span><br><span class="line"><span class="function">ForwardIter <span class="title">lower_bound</span><span class="params">(ForwardIter first, ForwardIter last,<span class="keyword">const</span> _Tp&amp; val)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回一个非递减序列[first, last)中第一个大于val的位置。</span></span></span><br><span class="line"><span class="function">ForwardIter <span class="title">upper_bound</span><span class="params">(ForwardIter first, ForwardIter last, <span class="keyword">const</span> _Tp&amp; val)</span></span></span><br></pre></td></tr></table></figure><p>这两个方法一般是用于确定 <code>val</code> 的上下边界，因为作用是一个<strong>非递减序列</strong>，因此用二分查找最好不过了。下面就是 STL 中这两个方法的实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个算法中，first是最终要返回的位置</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lower_bound</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> size, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">0</span>, middle;</span><br><span class="line">    <span class="keyword">int</span> half, len;</span><br><span class="line">    len = size;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        half = len &gt;&gt; <span class="number">1</span>;    <span class="comment">// half 表示待查找序列的一半长度</span></span><br><span class="line">        middle = first + half;  <span class="comment">// 确定待查找序列的中间位置</span></span><br><span class="line">        <span class="comment">// 根据比较结果，更新待查找序列</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[middle] &lt; key)</span><br><span class="line">        &#123;</span><br><span class="line">            first = middle + <span class="number">1</span>;</span><br><span class="line">            len = len-half<span class="number">-1</span>;       <span class="comment">//在右边子序列中查找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            len = half;            <span class="comment">//在左边子序列（包含middle）中查找</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">upper_bound</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">array</span>, <span class="keyword">int</span> size, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">0</span>, len = size<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> half, middle;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        half = len &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        middle = first + half;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[middle] &gt; key)     <span class="comment">//中位数大于key,在包含last的左半边序列中查找。</span></span><br><span class="line">        &#123;</span><br><span class="line">            len = half;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            first = middle + <span class="number">1</span>;    <span class="comment">//中位数小于等于key,在右半边序列中查找。</span></span><br><span class="line">            len = len - half - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回想一下，我们日常见到的二分查找都是使用两个位置变量标记一段待查找序列，STL中使用一个起始位置和长度来标记一段待查找序列，都是通过缩小待查找范围来更新，原理并没有什么不同，实现的复杂度也是类似的。</p><p>这里附一个我自己平时用的二分查找的模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(<span class="keyword">int</span> *data, <span class="keyword">int</span> size, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = size - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid =  left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (data[mid] == target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (data[mid] &gt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里要特别注意，<code>&gt;&gt;</code> 和 <code>+</code> 运算符有优先级，所以必须使用 <code>()</code></strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;STL 中的算法都很精妙，有很多实现值得我们细究和学习。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://murphypei.github.io/categories/C-C/"/>
    
    
      <category term="C++" scheme="https://murphypei.github.io/tags/C/"/>
    
      <category term="binary" scheme="https://murphypei.github.io/tags/binary/"/>
    
      <category term="lower_bound" scheme="https://murphypei.github.io/tags/lower-bound/"/>
    
      <category term="upper_bound" scheme="https://murphypei.github.io/tags/upper-bound/"/>
    
  </entry>
  
  <entry>
    <title>神经网络量化方法</title>
    <link href="https://murphypei.github.io//blog/2019/11/neural-network-quantization.html"/>
    <id>https://murphypei.github.io//blog/2019/11/neural-network-quantization.html</id>
    <published>2019-11-18T02:53:26.000Z</published>
    <updated>2020-03-26T08:19:37.614Z</updated>
    
    <content type="html"><![CDATA[<p>神经网络虽然在多个领域取得了非常巨大的成就，但是其本质是大量参数的拟合和泛化，如果想处理更加复杂的任务，在没有过拟合的情况下，增加训练数据和加大网络规模无疑是简单有效的手段。现实情况就是这么做的，但是巨大的参数量和复杂的网络结构造成了两个主要的问题：模型体积和运算速度。这两个问题会带来诸如内存容量，内存存取带宽，移动端还有电量消耗等一系列问题，大大限制了神经网络的应用场景。</p> <a id="more"></a><h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>为了解决这些问题，目前的研究方向主要就是两方面：一是精心设计小巧而有效的网络结构取代大网络模型，二是通过压缩和编码的方式直接减小现有网络的规模。量化就是一种很好的压缩和编码方式，量化的目的很简单，就是减小存储体积和加速运算，有效解决神经网络的根本问题，并且在实际的一些应用中表现出色，也是目前采用最广泛的压缩和编码方式。如果在一些小巧的网络中再使用量化，就可以进一步压缩和加速网络，使其能够移植到移动端，例如，TensorFlow 量化的 MobileNetV1  仅为 4.8 MB，这甚至比大多数 GIF 动图还要小，从而可以轻松地部署在任何移动平台上。</p><p>量化简单来说就是使用一种低精度的方式来作为存储和计算的数值表示方式。一般而言，在神经网络构建和训练时使用 float，也就是 FP32 作为一种通用的数据表示方式。量化使用 FP16（半精度浮点），INT8/UINT8（8 位的定点整数）等低精度数值格式来存储以及计算，目前低精度往往都是指 INT8/UINT8。当然，存储和计算并不是严格要保持一致的，有些参数或操作符必须采用 FP32 格式才能保持准确度，因此还有一种混合精度的表示方式，<a href="https://devblogs.Nvidia.com/mixed-precision-training-deep-neural-networks/" target="_blank" rel="noopener">TensorRT 中就使用了这种计算方式</a>。也有一些更加特殊的量化方式，二进制（0，1）、三元量化（-1，0，+1）、4 位整数等等，这些特殊的方式可以在一些特殊的网络中应用，用于进一步压缩，不过本文不对这些方法进行表述，有兴趣可以查阅这篇关于<a href="https://arxiv.org/abs/1710.09282" target="_blank" rel="noopener">模型压缩和加速的综述</a>。因为不同精度数值表示的范围和单位数值都不一样（如下表所示），因此我们必须做点什么来减少这种精度损失。</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Dynamic Range</th><th style="text-align:center">Min Positive Value</th></tr></thead><tbody><tr><td style="text-align:center">FP32</td><td style="text-align:center">-3.4x10^38 ~ +3.4x10^38</td><td style="text-align:center">1.4x10^-45</td></tr><tr><td style="text-align:center">FP16</td><td style="text-align:center">-65504 ~ +65504</td><td style="text-align:center">5.95x10^-8</td></tr><tr><td style="text-align:center">INT8</td><td style="text-align:center">-128 ~ +127</td><td style="text-align:center">1</td></tr></tbody></table></div><p>本文将简要介绍目前应用最为广泛的 NVIDIA 的 TensorRT 和 Google 的 IAO 量化方法，这两个量化方法都属于 8-bit 量化，其本质原理是类似的，只不过在一些实际应用操作上面，各有自己的理解和不同。</p><h2 id="TensorRT-量化方法"><a href="#TensorRT-量化方法" class="headerlink" title="TensorRT 量化方法"></a>TensorRT 量化方法</h2><p>神经网络的计算主要集中在<strong>卷积层和全连接层</strong>，量化也是针对这两个层做的。这两个层的计算都是可以表示为：output = input * weights + bias。因为现在的深度学习框架会将卷积和全连接层的计算都打包成矩阵相乘的形式，因此大量的计算都集中在矩阵相乘上了。TensorRT 的量化思路就是用 INT8 代替 FP32 进行两个矩阵相乘计算。</p><h3 id="TensorRT-量化原理"><a href="#TensorRT-量化原理" class="headerlink" title="TensorRT 量化原理"></a>TensorRT 量化原理</h3><p>TensorRT 的线性量化公式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tensor Values = FP32 scale factor * INT8 array + FP32 bias</span><br></pre></td></tr></table></figure><p>在这个量化公式中，FP32 数值（Tensor Values）被表示成 INT8 数值（INT8 array）乘以量化因子加上一个量化偏，两个参数均为 FP32 类型。因此，利用上述的公式可以表示神经网络中两个矩阵相乘：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = scale_A * QA + bias_A</span><br><span class="line">B = scale_B * QB + bias_B</span><br><span class="line">A * B = scale_A * scale_B * QA * QB + scale_A * QA * bias_B + scale_B * QB * bias_A + bias_A * bias_B</span><br></pre></td></tr></table></figure><p>NVIDIA 研究人员通过实现发现，其实我们并不需要在量化的时候加上偏置。我理解主要是因为偏置对于一组数值而言，其改变的是数值的分布位置，但是当前神经网络的归一化操作很多，因此可以去掉偏置。当然了，实验出的结果更有说服力。因此两个矩阵相乘的量化表示可以简化为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A * B = scale_A * scale_B * QA * QB</span><br></pre></td></tr></table></figure><p>这样就很明显了，只要我们有两个矩阵的 scale 以及量化后的矩阵，我们就可以表示其 FP32 的相乘结果。而量化后的矩阵就是 FP32 除以 scale 得到的，FP32 的数值是已知的（训练好的参数或者输入），因此量化的问题就变成了如何得到量化参数 scale factor。</p><p>既然是相乘，我们首先想大了线性映射，线性映射就是找一个值除以 INT8 的最大值，就可以求得 scale factor。TensorRT 介绍关于这个线性映射倍数的求解方法，有两种不同的方式：</p><p><img src="/images/posts/dl/quantization/map.jpg" alt></p><ul><li>非饱和映射：找到这组 FP32 数值的绝对值最大值 |max| 作为 FP32 的映射最大值</li><li>饱和映射：通过其他方法找到一个更加合适的阈值 T&lt;=|max| 作为 FP32 的映射最大值</li></ul><p>很明显，如果数值分布不够集中，比如有一些奇异点（很大或者很小），非饱和映射导致 scale factor 偏大，因为 INT8 单位精度远小于 FP32，就会让 FP32 中很多数集中在 INT8 的某几个数字上，带来了严重的精度影响。因此 TensorRT 采用了饱和映射，并且使用 KLD（KL 散度）方法寻找阈值 T。下图是 NVIDIA 官方 PPT 中对一些网络的激活值的分布的统计：</p><p><img src="/images/posts/dl/quantization/fp32_number_count.jpg" alt></p><h3 id="KLD"><a href="#KLD" class="headerlink" title="KLD"></a>KLD</h3><p>FP32 用 INT8 表示，本质就是一种再编码，这个学过通信技术的同学可能会容易理解。对于两种不同的编码方式，可以采用一种称为交叉熵的方式计算二者的差异性，本文并不想过多的着墨于信息论中关于信息熵的这些知识，这些知识通过搜索引擎可以获取，只介绍相关知识。</p><p>首先是信息熵，对于一种编码，其是符号的集合，每种符号都有其出现的概率，<strong>信息熵</strong>的大小可以表示为：</p><script type="math/tex; mode=display">H(X,p) = -\sum_{x \in X}p(x)\log p(x)</script><p>其中 $p(x)$ 是符号出现的概率，$-\log p(x)$ 就是这个符号的信息，这就是信息论的核心和理论基础，信息的表示。$-\log p(x)$ 也可以看作是每个符号的编码长度，因此信息熵也可以表示编码长度的期望。</p><p>当我们使用另一种编码 $q(x)$ 方式去表示这个信息，求得编码长度的期望称之为<strong>交叉熵</strong>：</p><script type="math/tex; mode=display">H(X,p,q) = -\sum_{x \in X}p(x)\log q(x)</script><p>一般而言，信息熵是最优编码，因此其编码期望就是最小编码长度，因此交叉熵必然是大于等于信息熵，我们可以计算两种不同编码表示的长度期望的差异，也是两个信息熵的差值：</p><script type="math/tex; mode=display">D(p||q) = H(X,p,q) - H(X,p) = -\sum_{x \in X}p(x)(\log q(x)- \log p(x))</script><p>上述两个信息熵的差值称之为<strong>相对熵</strong>，KLD 就是使用相对熵来描述两个不同数值分布的差异性。如果想要量化某一组数值，其具体做法如下：</p><ol><li>准备一个校准数据集，覆盖模型的使用场景即可，数量不需要很多。</li><li>将数据集的每张图片都通过模型做一次预测，在这个过程中，对所有要量化的层的 FP32 数值分布进行统计，得到 |max|。<ul><li>量化是针对每个 channel 单独做的，因此<strong>卷积层的每个 channel 都是单独统计、计算和量化的</strong>，后续操作也是。</li></ul></li><li>将 0~|max| 分成 n 个 bin，然后再次遍历所有图片，让每个量化层中的数值落到其属于的 bin 中，统计每个 bin 的数目。<ul><li>|max| / n 就可以得到每个 bin 的宽度 w，因此  就分为了 0~w, w~2*w…(n-1)*w~|max| 总共 n 个 bin。</li><li>对每个数值按照其绝对值分到不同 bin 中。</li><li>TensorRT 官方使用的 n 是 2048，mxnet 是 4096，n 越大越好，但是计算量会上升。</li></ul></li><li>遍历第 128~n 个 bin：<ul><li>以当前 bin 的中值作为阈值 T，在其上做截断，将大于当前 bin 以外的 bin 的统计数目加到当前 bin 上，这一步是为了减少直接抹去这些数值带来的影响；</li><li>计算此时的概率分布 P，每个 bin 的概率就是其统计数目除以数值的总数；</li><li>创建一个新的编码 Q，其长度是128，其元素的值就是 P 量化后的 INT8 数值（正数是0~+127，负数是-128~-1)；</li><li>因为 Q 分布只有 128 个编码，为了计算交叉熵，将其扩展到和 P 同样的长度；</li><li>计算 P 和 Q 的相对熵，记录当前相对熵和阈值 T</li></ul></li><li>选择最小的相对熵和其对应阈值 T，计算 scale factor = T / 127<ul><li>实际代码中使用的是 scale factor = 127 / T，这样 FP32 到 INT8 量化的时候可以使用乘法而不是除法。</li></ul></li><li>对每个 bin，取其中值作为这个 bin 当前的 FP32 表示，然后除以 scale factor，然后四舍五入，就得到了其量化后的 INT8 数值，将这个 bin 中所有的 FP32 数值都映射为这个 INT8 表示的数。多个 bin 可能映射为同一个 INT8 数字。</li></ol><p>上述流程就是 TensorRT 中寻找阈值和计算 scale factor 的流程，有几个点还需要注意：首先为什么阈值遍历要从 128 开始呢？因为 INT8 可以表示的整数个数（正值）有128个，小于这个数值则直接一一对应即可。其次如果扩展 q 分布呢？TensorRT 官方 PPT 的例子，据说是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">P=[1 0 2 3 5 3 1 7]     // fp32 的统计直方图，T=8</span><br><span class="line">// 假设只量化到两个 bins，即量化后的值只有 -1/0/+1 三种</span><br><span class="line">Q=[1+0+2+3, 5+3+1+7] = [6, 16]</span><br><span class="line">// P 和 Q 现在没法做 KL 散度，所以要将 Q 扩展到和 P 一样的长度</span><br><span class="line">Q_expand = [6/3, 0, 6/3, 6/3, 16/4, 16/4, 16/4, 16/4] = [2 0 2 2 4 4 4 4]  // P 中有 0 时，不算在内</span><br><span class="line">D = KL(P||Q_expand)  // 这样就可以做 KL 散度计算了</span><br></pre></td></tr></table></figure><p>这个扩展的操作，就像图像的上采样一样，将低精度的统计直方图(Q)，上采样的高精度的统计直方图上去(Q_expand)。由于 Q 中一个 bin 对应 P 中的 4 个bin，因此在 Q 上采样的 Q_expand 的过程中，所有的数据要除以 4。但若分布P 中有 bin 值为 0 时，是不算在内的，所以 6 只需要除以 3。</p><p>以上内容很多细节都来自 NCNN，其使用了和 TensorRT 一样的量化机制，因为 TensorRT 不开源，细节不得知，因此只有通过 NCNN 代码来了解一些细节的实现。下面具体讲讲 NCNN 中量化的一些实现。</p><h3 id="NCNN-量化实现"><a href="#NCNN-量化实现" class="headerlink" title="NCNN 量化实现"></a>NCNN 量化实现</h3><p>NCNN 主要对 conv 和 fc 的计算进行量化，具体就是对输入数据 input_data 和 模型权重 weights 进行量化，实现的量化机制就是 TensorRT 的量化方法。我主要讲解 conv 层的量化实现。</p><p>首先是通过校准数据集生成量化表，这个量化表主要存放的就是量化的 scale factor，这个表的生成是离线的，量化表的实现在 <a href="https://github.com/Tencent/ncnn/blob/master/tools/quantize/ncnn2table.cpp" target="_blank" rel="noopener">ncnn2table.cpp</a> 中。NCNN 将 weights 和 input_data 分开计算的 scale factor。</p><h4 id="量化权重"><a href="#量化权重" class="headerlink" title="量化权重"></a>量化权重</h4><p>对于 weights，NCNN 并没有通过 KLD 来寻找阈值，而是<strong>直接利用最大值来计算 scale factor</strong>，这个做法和 NVIDIA 官方 PPT 中的做法是一致的，其中也提到了 <strong>weights 不需要饱和量化，只需要非饱和量化</strong>。我猜测其原因是 weights 的数值分布比较集中。关于 weights 的 scale factor 计算可以查看 <a href="https://github.com/Tencent/ncnn/blob/master/tools/quantize/ncnn2table.cpp#L142" target="_blank" rel="noopener">QuantNet::get_conv_weight_blob_scales</a> 这个函数。这里贴出其核心逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;((ncnn::Convolution*)layer)-&gt;num_output; n++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">const</span> ncnn::Mat weight_data_n = ((ncnn::Convolution*)layer)-&gt;weight_data.range(weight_data_size_output * n, weight_data_size_output);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">float</span> *data_n = weight_data_n;</span><br><span class="line">    <span class="keyword">float</span> max_value = <span class="built_in">std</span>::numeric_limits&lt;<span class="keyword">float</span>&gt;::min();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight_data_size_output; i++)</span><br><span class="line">        max_value = <span class="built_in">std</span>::max(max_value, <span class="built_in">std</span>::<span class="built_in">fabs</span>(data_n[i]));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (quant_6bit)</span><br><span class="line">        scales.push_back(<span class="number">31</span> / max_value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        scales.push_back(<span class="number">127</span> / max_value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="量化输入数据"><a href="#量化输入数据" class="headerlink" title="量化输入数据"></a>量化输入数据</h4><p>可以看出，NCNN 居然还有 6-bit 量化。还有补充一点就是 weights 是固定的，因此 weights 的量化是可以离线做的，而且可以看出，对于卷积层，其按照 channel 数目（<code>weight_data_size_output</code>），每个 channel 分别量化。</p><p>weights 的量化比较简单，麻烦的是输入数据的量化。NCNN 是按需量化，也就是如果这一层需要量化，才会将输入的数据进行量化，这个输入的数据因为是在 inference 的时候才能拿到，所以不可能离线量化，只能在线。而且因为输入数据分布不规律（conv 和 fc 的输入来自上一层的激活值），因此需要用饱和量化，也就是 KLD 寻找最佳阈值，这一步如果放到 inference 在线操作，太耗时了，因此使用校准数据集去模拟 inference 行为，然后在这个过程中寻找最佳阈值，计算 scale factor，作为输入数据的量化尺度。每一层都只有一个输入数据的 scale factor，并且将其也保存在量化表中。这部分代码实现在 <a href="https://github.com/Tencent/ncnn/blob/master/tools/quantize/ncnn2table.cpp#L514" target="_blank" rel="noopener">post_training_quantize</a> 函数中。核心逻辑如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> QuantizeData::get_data_blob_scale()</span><br><span class="line">&#123;   </span><br><span class="line">    normalize_histogram();</span><br><span class="line">    threshold_bin = threshold_distribution(histogram);</span><br><span class="line">    threshold = (threshold_bin + <span class="number">0.5</span>) * histogram_interval;</span><br><span class="line">    scale = <span class="number">127</span> / threshold;</span><br><span class="line">    <span class="keyword">return</span> scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用量化计算"><a href="#使用量化计算" class="headerlink" title="使用量化计算"></a>使用量化计算</h4><p>有了量化参数 scale factor，就可以使用它将 FP32 数值转换到 INT8了。权重是已经离线量化好的，因此只需要将输入按照量化表中那个已经计算好的 scale factor 进行量化就可以了。<strong>NCNN 并不量化卷积层和全连接层的偏置项</strong>，因此需要将矩阵乘法得到的结果（INT32）<strong>反量化</strong>到 FP32，然后和 bias 做加法，输出到下一层。其中反量化也很简单，只需要使用权重和输入数据量化的 scale factor 乘积的倒数作为反量化的 scale factor 即可。计算流程图如下：</p><p><img src="/images/posts/dl/quantization/ncnn_conv_quantization.jpg" alt></p><p>NCNN 中还有一些针对多个量化层的融合机制，简单来说就是当一个 Conv1 后面紧跟着另一个 Conv2 时，NCNN 会进行 requantize 的操作。大致意思就是在得到 Conv1 的 INT32 输出后，会顺手帮 Conv2 做量化，得到 Conv2 的 INT8 输入。这中间不会输出 FP32 的结果，节省一次内存读写。</p><p><img src="/images/posts/dl/quantization/ncnn_conv_quantization.jpg" alt></p><p>针对具体的操作过程以及上图，都引自<a href="https://zhuanlan.zhihu.com/p/71881443" target="_blank" rel="noopener">这篇文章</a>，有兴趣可以查看。</p><h2 id="IAO-量化方法"><a href="#IAO-量化方法" class="headerlink" title="IAO 量化方法"></a>IAO 量化方法</h2><p>IAO 是 Google 提出的量化方法，主要应用在 TensorFlow Lite 中，有了 TensorRT 的知识铺垫，讲 IAO 就比较简单了。</p><h3 id="IAO-量化原理"><a href="#IAO-量化原理" class="headerlink" title="IAO 量化原理"></a>IAO 量化原理</h3><p>首先是量化公式：</p><script type="math/tex; mode=display">Q = \frac{R}{S} + Z</script><p>其中，$R$ 表示真实的浮点值，$Q$ 表示量化后的定点值，$Z$ 表示 0 浮点值对应的量化定点值，也称<strong>零点漂移</strong>，$S$ 则为量化的 scale factor，$S$ 和 $Z$ 的求值公式如下：</p><script type="math/tex; mode=display">S = \frac{R_{max} - R_{min}}{Q_{max} - Q_{min}}</script><script type="math/tex; mode=display">Z = Q_{max} - \frac{R_{max}}{S}</script><p><strong>这里的 $S$ 和 $Z$ 均是量化参数，$S$ 是 FP32 类型，而 $Z$ 是 INT8 类型</strong>。 $Q$ 和 $R$ 均可由公式进行求值，不管是量化后的 $Q$ 还是反推求得的浮点值 $R$，如果它们超出各自可表示的最大范围，那么均需要进行截断处理。</p><p>文章中指出 0 值对于神经网络具有重大意义，需要小心的处理，因此引入了零点偏移的概念。在我个人看来，我觉得<strong>这个量化公式和 TensorRT 中权重量化的区别就在于加入了 TensorRT 去掉的偏置项</strong>。虽然 NVIDIA 研究人员用实验说明了这个偏置项不重要，但是 Google 也有自己的理由和考虑，我觉得求同存异，看个人的理解吧。下面以一组例子说明这个公式的用法：</p><p>假设训练后的权重或者激活值的分布范围是[-3.0, 7.0]，INT8 量化后表示的范围[-128，127]，$S$ 和 $Z$ 可以计算如下：</p><script type="math/tex; mode=display">S=\frac{7.0-(-3.0)}{127-(-128)}=\frac{10}{255} \approx 0.039216</script><script type="math/tex; mode=display">Z=127- \frac{7.0}{0.039216} \approx -51.498572 \approx -51</script><p>假设我们有一个激活值 0.78，即 $R=0.78$，则对应定点值求解如下：</p><script type="math/tex; mode=display">Q=\frac{0.78}{0.039216} + (-51) \approx -31.11016 \approx -31</script><p>可以看出，只要确定了浮点数的边界（定点数的边界时已知的），计算量化参数以及量化浮点数这些都和 TensorRT 以及 NCNN 非常的像，<strong>只不过 IAO 没有使用 KLD 那种方式寻找最佳阈值，而是直接使用要量化的数值集合的浮点数边界，和 NCNN 中 weights 的量化类似</strong>。</p><h3 id="IAO-量化计算"><a href="#IAO-量化计算" class="headerlink" title="IAO 量化计算"></a>IAO 量化计算</h3><p>和 TensorRT，我们根据量化公式也可以直接表示矩阵相乘：</p><script type="math/tex; mode=display">S_3(q_3^{(i,k)}-Z_3)=\sum_{j=1}^N{S_1(q_1^{(i,j)}-Z_1)S_2(q_2^{(j,k)}-Z_2)}</script><script type="math/tex; mode=display">q_3^{(i,k)}=Z_3 + M \sum_{j=1}^N{(q_1^{(i,j)}-Z_1)(q_2^{(j,k)}-Z_2)}</script><p>其中 $M=\frac{S_1S_2}{S_3}$，可以看到，整个式子中只有 $M$ 是浮点数，其余都是整型（INT8 或者 INT32）。实验经验表明 $M$ 的范围是 (0, 1)，因此想办法将其也用整数表示，做法如下：</p><script type="math/tex; mode=display">M_0=2^nM</script><p>$M_0$ 是一个 (0.5, 1] 的数，记录 $M$ 到 $M_0$ 的扩大（缩小）幅度 $n$（在计算机中可以用右移位数表示），然后将 $M_0$ 乘以 $2^{31}$，截断，得到一个 INT32 整形数 $M_q$。这里还有一个特别处理，如果 $M_0$ 接近 1，上述乘积结果 $M_q$ 等于 $2^{31}$，超过 INT32 表示的最大值（$2^{31}$-1），因此将结果除以 2，相应的将记录的倍数 n 也减小 1。这样我们就可以用一个 INT32 整型数 $M_q$ 和 一个变化因子 $n$ 来表示浮点数 $M$，从 $M_q$ 恢复 $M$ 就是上述过程的逆向操作。</p><h3 id="IAO-量化训练"><a href="#IAO-量化训练" class="headerlink" title="IAO 量化训练"></a>IAO 量化训练</h3><p>IAO 方法将权重、激活值及输入值均全部做 INT8 量化，并且将所有模型运算操作置于 INT8 下进行执行，以达到最好的量化效果。为了达到此目的，需要实施量化精度补偿训练。下面还是以一个卷积层计算的具体例子说明 IAO 量化训练：</p><ol><li>输入 量化的特征图 lhs_quantized_val，INT8 类型，偏移量 lhs_zero_point，INT32 类型；</li><li>输入 量化的卷积核 rhs_quantized_val，INT8 类型，偏移量 rhs_zero_point，INT32 类型；</li><li>转换 INT8 到 INT32类型；</li><li>每一块卷积求和（INT32 乘法求和有溢出风险，可换成固定点小数树乘法）；<ul><li><code>int32_accumulator += (lhs_quantized_val(i, j) - lhs_zero_point) * (rhs_quantized_val(j, k) - rhs_zero_point)</code></li></ul></li><li>输入 量化的乘子 quantized_multiplier（$M_q$，INT32 类型 ）和右移次数记录 right_shift（$n$)，INT 类型；<ul><li><code>real_multiplier = (S_in * S_W / S_out) * (2^n)</code></li><li><code>quantized_multiplier = round(real_multiplier * (1 &lt;&lt; 31))</code></li></ul></li><li>计算乘法，得到 INT32 类型的结果 (INT32乘法有溢出风险，可换成固定点小数树乘法);<ul><li><code>int32_result = quantized_multiplier * int32_accumulator</code></li></ul></li><li>再左移动 right_shift 位还原，得到 INT32 的结果；</li><li>最后再加上结果的偏移量 result_zero_point；</li><li>将 INT32 类型结果强制转换到 INT8 类型，就得到了量化后的矩阵计算结果；</li><li>之后再反量化到浮点数，更新统计输出值分布信息 $R<em>{max}$, $R</em>{min}$；</li><li>再量化回 INT8；</li><li>之后经过量化激活层；</li><li>最后反量化到浮点数，本层网络输出；</li><li>进入下一层，循环执行 1~12 步骤</li></ol><p>可以看出，上述的操作就是在传统神经网络的前向传播过程中加入量化和反量化的操作，这其中无疑引入了量化带来的精度误差，我个人理解量化训练的目的就是为了让参数分布适应这种误差。Relu层的流程可以表示如下：</p><p><img src="/images/posts/dl/quantization/iao_relu_layer.jpg" alt></p><p>量化精度补偿训练需要一个具有代表性的小数据集，用于统计激活值和输入值等非确定性值的浮点型范围，以便进行精准量化，而输出值的 scale 计算则更加有意思，在训练最开始的时候将输出的值看作量化好的 INT8 类型，然后通过训练，不同搜集值得范围、计算 scale、调整，最后收敛。总体而言，其思想是和 TensorRT 中的校准数据集类似，只不过 IAO 方法直接收集的数值集合的最大最小值。全整型量化的输入输出依然是浮点型的，但如果某些 Op 未实现该方法，则转化是没问题的且其依然会自动保存为浮点型。</p><p>虽然是直接收集，但是针对卷积层和全连接层以及激活层的处理方式还是不同的。卷积层和全连接层处理方式类似都是直接统计最大值最小值，而激活层的值变化较大，因此使用一种称为 EMA 的方法来统计最大最小值。量化精度补偿训练一般是浮点模型训练的比较好的时候再进行，并且模拟量化的时候，反向传播仍然使用 FP32 类型，这是为了保证反向传播的精度。</p><p>TensorFlow 中使用 IAO 方法也将卷积和结果和偏置项相加，激活层等操作进行了融合，还有一些实现细节，包括 BN 的更新等我就不展开叙述了。融合的计算流程如下：</p><p><img src="/images/posts/dl/quantization/iao_fusion.png" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后想说说量化适合的应用场景，由于量化是牺牲了部分精度（虽然比较小）来压缩和加速网络，因此不适合精度非常敏感的任务。量化目前最适合的领域就是图像处理，因为图片的信息冗余是非常大的，比如相邻一块的像素几乎都一模一样，因此用量化处理一些图像任务，比如目标检测、分类等对于精度不是非常敏感的 CV 任务而言是很适合的。</p><p>需要说明的是，量化只是深度神经网络压缩和加速的一种方法，还有包括蒸馏、矩阵秩分解、网络剪枝等多种方法。但是量化是一种已经获得了工业界认可和使用的方法，在训练（training）中使用 FP32，在推理（inference）期间使用 INT8 这套量化体系已经被包括 TensorRT，TensorFlow，PyTorch，MxNet 等众多深度学习框架启用。</p><p>就这两套方案而言，TensorRT 更加简单，实现起来也比较方便，IAO 方法在理论上精度更高，但是实际我自身只使用过前者，并没有验证过。后者如果使用 TensorFlow 的接口，使用也不难。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://zhuanlan.zhihu.com/p/71881443" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/71881443</a></li><li><a href="http://on-demand.gputechconf.com/gtc/2017/presentation/s7310-8-bit-inference-with-tensorrt.pdf" target="_blank" rel="noopener">http://on-demand.gputechconf.com/gtc/2017/presentation/s7310-8-bit-inference-with-tensorrt.pdf</a></li><li><a href="http://openaccess.thecvf.com/content_cvpr_2018/papers/Jacob_Quantization_and_Training_CVPR_2018_paper.pdf" target="_blank" rel="noopener">http://openaccess.thecvf.com/content_cvpr_2018/papers/Jacob_Quantization_and_Training_CVPR_2018_paper.pdf</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;神经网络虽然在多个领域取得了非常巨大的成就，但是其本质是大量参数的拟合和泛化，如果想处理更加复杂的任务，在没有过拟合的情况下，增加训练数据和加大网络规模无疑是简单有效的手段。现实情况就是这么做的，但是巨大的参数量和复杂的网络结构造成了两个主要的问题：模型体积和运算速度。这两个问题会带来诸如内存容量，内存存取带宽，移动端还有电量消耗等一系列问题，大大限制了神经网络的应用场景。&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="https://murphypei.github.io/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="https://murphypei.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="TensorRT" scheme="https://murphypei.github.io/tags/TensorRT/"/>
    
      <category term="神经网络" scheme="https://murphypei.github.io/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="量化" scheme="https://murphypei.github.io/tags/%E9%87%8F%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>CUDA 多线程并行</title>
    <link href="https://murphypei.github.io//blog/2019/10/cuda-parallel.html"/>
    <id>https://murphypei.github.io//blog/2019/10/cuda-parallel.html</id>
    <published>2019-10-30T09:47:03.000Z</published>
    <updated>2020-04-12T04:18:10.812Z</updated>
    
    <content type="html"><![CDATA[<p>cuda 中核函数执行使用多线程并行（SIMD）的方式，同时计算多个数据，因此核函数的线程管理以及相应的任务分配就显得尤为重要。</p><a id="more"></a><p>首先说明一点，cuda 中使用 <code>dim3</code> 作为三维数据的表示方式，其表示的意义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dim3 <span class="title">blocks1D</span><span class="params">( <span class="number">5</span>       )</span></span>; <span class="comment">// 5*1*1</span></span><br><span class="line"><span class="function">dim3 <span class="title">blocks2D</span><span class="params">( <span class="number">5</span>, <span class="number">5</span>    )</span></span>;<span class="comment">// 5*5*1</span></span><br><span class="line"><span class="function">dim3 <span class="title">blocks3D</span><span class="params">( <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span> )</span></span>;<span class="comment">// 5*5*5</span></span><br></pre></td></tr></table></figure><p>再来看看 cuda 中 kernel 函数的典型调用形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel&lt;&lt;&lt;Dg, Db, Ns, S&gt;&gt;&gt;(params);</span><br></pre></td></tr></table></figure><ul><li>参数 <code>Dg</code> 是一个 <code>dim3</code> 类型，用于定义整个 grid 的维度，也就是一个 grid 中有多少个 block。<code>dim3 Dg(Dg.x, Dg.y, 1)</code> 表示 grid 中每行有 <code>Dg.x</code> 个block，每列有 <code>Dg.y</code> 个block，第三维恒为 1。整个 grid 中共有 <code>Dg.x*Dg.y</code> 个 block，其中 <code>Dg.x</code> 和 <code>Dg.y</code> 最大值为 65535。<ul><li>对于一个 grid，其中包含了多个 block，使用 <code>unit3</code> 类型的 <code>blockIdx</code> 来表示，通过 <code>blockIdx.x</code>，<code>blockIdx.y</code>，<code>blockIdx.z</code> 三个坐标可以定位 grid 中的一个 block。</li><li>注意：<code>dim3</code> 是手工定义的，主机端可见。<code>uint3</code> 是设备端在执行的时候可见的，不可以在核函数运行时修改，初始化完成后 <code>uint3</code> 值就不变了。他们是有区别的，这一点必须要注意。</li></ul></li><li>参数 <code>Db</code> 是一个 <code>dim3</code> 类型，用于定义一个 block 的维度，即一个 block 有多少个 thread。<code>Dim3 Db(Db.x, Db.y, Db.z)</code> 表示整个 block 中每行有 <code>Db.x</code> 个thread，每列有 <code>Db.y</code> 个thread，高度为 <code>Db.z</code>。<code>Db.x</code> 和 <code>Db.y</code>最大值为 512，<code>Db.z</code> 最大值为 62。 一个 block中 共有 <code>Db.x*Db.y*Db.z</code> 个 thread。不同计算能力这个乘积的最大值不一样。<ul><li>和在 grid 中定位一个 block 类似，在一个 block 中定位一个 thread 也是用一个 <code>unit3</code> 类型的 <code>threadIdx</code> 的三个坐标来表示的。</li></ul></li><li>参数 <code>Ns</code> 是一个可选参数，用于设置每个 block 除了静态分配的 shared memory 以外，最多能动态分配的 shared memory 大小，单位为 byte。不需要动态分配时该值为0或省略不写。</li><li>参数 <code>S</code> 是一个 <code>cudaStream_t</code> 类型的可选参数，初始值为零，表示该核函数处在哪个流之中。</li></ul><p>kernel 可以通过 grid 和 block 的设置实现了多线程并行计算，下面是 cuda 官方的一个向量相加的例子，其中的 kernel 函数就是实际计算程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../common/book.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N   (33 * 1024)</span></span><br><span class="line"></span><br><span class="line">__<span class="function">global__ <span class="keyword">void</span> <span class="title">add</span><span class="params">( <span class="keyword">int</span> *a, <span class="keyword">int</span> *b, <span class="keyword">int</span> *c )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tid = threadIdx.x + blockIdx.x * blockDim.x;</span><br><span class="line">    <span class="keyword">while</span> (tid &lt; N) &#123;</span><br><span class="line">        c[tid] = a[tid] + b[tid];</span><br><span class="line">        tid += blockDim.x * gridDim.x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">void</span> )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a, *b, *c;</span><br><span class="line">    <span class="keyword">int</span> *dev_a, *dev_b, *dev_c;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocate the memory on the CPU</span></span><br><span class="line">    a = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>( N * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">    b = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>( N * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line">    c = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>( N * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// allocate the memory on the GPU</span></span><br><span class="line">    HANDLE_ERROR( cudaMalloc( (<span class="keyword">void</span>**)&amp;dev_a, N * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) ) );</span><br><span class="line">    HANDLE_ERROR( cudaMalloc( (<span class="keyword">void</span>**)&amp;dev_b, N * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) ) );</span><br><span class="line">    HANDLE_ERROR( cudaMalloc( (<span class="keyword">void</span>**)&amp;dev_c, N * <span class="keyword">sizeof</span>(<span class="keyword">int</span>) ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fill the arrays 'a' and 'b' on the CPU</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        a[i] = i;</span><br><span class="line">        b[i] = <span class="number">2</span> * i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy the arrays 'a' and 'b' to the GPU</span></span><br><span class="line">    HANDLE_ERROR( cudaMemcpy( dev_a, a, N * <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">                              cudaMemcpyHostToDevice ) );</span><br><span class="line">    HANDLE_ERROR( cudaMemcpy( dev_b, b, N * <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">                              cudaMemcpyHostToDevice ) );</span><br><span class="line"></span><br><span class="line">    add&lt;&lt;&lt;<span class="number">128</span>,<span class="number">128</span>&gt;&gt;&gt;( dev_a, dev_b, dev_c );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy the array 'c' back from the GPU to the CPU</span></span><br><span class="line">    HANDLE_ERROR( cudaMemcpy( c, dev_c, N * <span class="keyword">sizeof</span>(<span class="keyword">int</span>),</span><br><span class="line">                              cudaMemcpyDeviceToHost ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// verify that the GPU did the work we requested</span></span><br><span class="line">    <span class="keyword">bool</span> success = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((a[i] + b[i]) != c[i]) &#123;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">"Error:  %d + %d != %d\n"</span>, a[i], b[i], c[i] );</span><br><span class="line">            success = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (success)    </span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">"We did it!\n"</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free the memory we allocated on the GPU</span></span><br><span class="line">    HANDLE_ERROR( cudaFree( dev_a ) );</span><br><span class="line">    HANDLE_ERROR( cudaFree( dev_b ) );</span><br><span class="line">    HANDLE_ERROR( cudaFree( dev_c ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// free the memory we allocated on the CPU</span></span><br><span class="line">    <span class="built_in">free</span>( a );</span><br><span class="line">    <span class="built_in">free</span>( b );</span><br><span class="line">    <span class="built_in">free</span>( c );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中可以通过 <code>threadIdx.x + blockIdx.x * blockDim.x</code> 定位当前执行线程的 index。但是我们实际操作的数据长度(33*1024) 大于设置的线程数量 (128*128)。因此一个线程可能会处理多个数据，因此使用 <code>tid += blockDim.x * gridDim.x</code> 来执行多个数据的处理。当然，需要判断 <code>tid</code> 是否越界。</p><p>因为我们都是通过多线程并行来实现 kernel 的高效执行，因此也可以说编写核函数的精髓就是如何利用线程的序号（索引值）来分配计算任务。这里有一个题外话，<strong>之所以在硬件上将线程抽象成三维数组来表示，就是为了方便图像处理里，利用三维的线程索引来对应图像数据索引，并行加速，其实对于底层硬件，不存在三维线程的概念</strong>。</p><p>至于对于一个任务应该分配多少线程，grid 和 block 应该设置为多大，这根据需求和硬件素质。通常选取 2 的倍数作为线程总数，合理地平均分配任务到各个线程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;cuda 中核函数执行使用多线程并行（SIMD）的方式，同时计算多个数据，因此核函数的线程管理以及相应的任务分配就显得尤为重要。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://murphypei.github.io/categories/C-C/"/>
    
    
      <category term="cuda" scheme="https://murphypei.github.io/tags/cuda/"/>
    
      <category term="kernel" scheme="https://murphypei.github.io/tags/kernel/"/>
    
      <category term="simd" scheme="https://murphypei.github.io/tags/simd/"/>
    
      <category term="block" scheme="https://murphypei.github.io/tags/block/"/>
    
      <category term="grid" scheme="https://murphypei.github.io/tags/grid/"/>
    
  </entry>
  
  <entry>
    <title>C++11 的随机数</title>
    <link href="https://murphypei.github.io//blog/2019/10/cpp-random.html"/>
    <id>https://murphypei.github.io//blog/2019/10/cpp-random.html</id>
    <published>2019-10-30T09:46:32.000Z</published>
    <updated>2020-04-12T04:18:10.812Z</updated>
    
    <content type="html"><![CDATA[<p>C++11 带来了丰富便捷的随机数生成方法。</p><a id="more"></a><p>C++11 的随机数分为三个层次，下面分别叙述。</p><h3 id="产生随机数"><a href="#产生随机数" class="headerlink" title="产生随机数"></a>产生随机数</h3><p>标准库提供了一个<strong>非确定性随机数</strong>生成设备。在 Linux 的实现中，是读取 <code>/dev/urandom</code> 设备；Windows 的实现是用<code>rand_s</code>，在这里强烈谴责一下。<code>random_device</code> 提供 <code>()</code> 操作符，用来返回一个 <code>min()</code> 到 <code>max()</code> 之间的一个数字。因此 Linux（包括类 Unix）下调用 <code>random_device()</code> 获取的是一个真随机数，Windows 是伪随机数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::random_device rd;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;<span class="number">20000</span>; ++n)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rd() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="随机数引擎"><a href="#随机数引擎" class="headerlink" title="随机数引擎"></a>随机数引擎</h3><p>C++ 中的均匀随机位生成器 (URBG) ，也就是随机数引擎是伪随机数生成器。这种随机数生成器传入一个种子，根据种子生成随机数，这也是我们最常见的一种随机数生成器。这种随机数引擎本质是一种算数算法，因此<strong>相同的种子多次调用产生的随机数是完全相同的</strong>。</p><p>标准提供三种常用的引擎：linear_congruential_engine，mersenne_twister_engine 和 subtract_with_carry_engine。第一种是线性同余算法，第二种是梅森旋转算法，第三种带进位的线性同余算法。第一种是最常用的，而且速度也是非常快的；第二种号称是最好的伪随机数生成器；第三种目前还不太清楚。</p><p>随机数引擎接受一个整形参数当作种子，不提供的话，会使用默认值。如果想多次运行产生相同的随机数，可以使用一个确定的数作为种子。如果是想每次运行生成不一样的随机数，Linux 推荐使用 <code>random_device</code> 来产生一个随机数当作种子，windows 产生一个伪随机数作为种子吧。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::random_device rd;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function">mt19937 <span class="title">mt</span><span class="params">(rd())</span></span>;<span class="comment">// 梅森旋转算法</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">10</span>; n++)</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; mt() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="随机分布"><a href="#随机分布" class="headerlink" title="随机分布"></a>随机分布</h3><p>STL 标准库还提供各种各样的随机分布，不过我们经常用的比较少，比如平均分布，正太分布…使用也很简单。随机分布是利用一定的算法处理 URBG 的输出，以使得输出结果按照定义的统计概率密度函数分布。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//平均分布</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::random_device rd;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::uniform_int_distribution&lt;&gt; dis(<span class="number">1</span>, <span class="number">6</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;<span class="number">10</span>; ++n)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; dis(gen) &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//正太分布</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iomanip&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::random_device rd;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// values near the mean are the most likely</span></span><br><span class="line">    <span class="comment">// standard deviation affects the dispersion of generated values from the mean</span></span><br><span class="line">    <span class="built_in">std</span>::normal_distribution&lt;&gt; d(<span class="number">5</span>,<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hist;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">0</span>; n&lt;<span class="number">10000</span>; ++n) &#123;</span><br><span class="line">        ++hist[<span class="built_in">std</span>::round(d(gen))];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : hist) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::fixed &lt;&lt; <span class="built_in">std</span>::setprecision(<span class="number">1</span>) &lt;&lt; <span class="built_in">std</span>::setw(<span class="number">2</span>)</span><br><span class="line">                  &lt;&lt; p.first &lt;&lt; <span class="string">' '</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">string</span>(p.second/<span class="number">200</span>, <span class="string">'*'</span>) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++11 带来了丰富便捷的随机数生成方法。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://murphypei.github.io/categories/C-C/"/>
    
    
      <category term="C++" scheme="https://murphypei.github.io/tags/C/"/>
    
      <category term="C++11" scheme="https://murphypei.github.io/tags/C-11/"/>
    
      <category term="random" scheme="https://murphypei.github.io/tags/random/"/>
    
      <category term="engine" scheme="https://murphypei.github.io/tags/engine/"/>
    
  </entry>
  
  <entry>
    <title>程序绑定 CPU 核心</title>
    <link href="https://murphypei.github.io//blog/2019/09/bind-cpu.html"/>
    <id>https://murphypei.github.io//blog/2019/09/bind-cpu.html</id>
    <published>2019-09-26T08:33:17.000Z</published>
    <updated>2020-04-12T04:18:10.812Z</updated>
    
    <content type="html"><![CDATA[<p>有时候需要将程序绑定到固定 CPU 的某个核心上运行。</p><a id="more"></a><p>我们知道多核 CPU 系统中，进程和线程的运行在哪个核心是由操作系统内核根据一定的调度算法进行调度的。但是实际软件开发过程中，我们出于一些目的，想要进程或者线程稳定运行在某个 CPU  核心上。比如我想测试两种算法的性能，因为服务器上有一些其他的进程干扰，测试的时间总是有波动，此时就需要将测试程序稳定在某个核心上测试。</p><p>Linux 中有 CPU 亲和性这种说法（Windows 有没有我不知道，也不关心）。引用一下维基百科的说法：</p><blockquote><p>CPU 亲和性就是绑定某一进程（或线程）到特定的 CPU（或 CPU 集合），从而使得该进程（或线程）只能运行在绑定的 CPU（或 CPU 集合）上。CPU 亲和性利用了这样一个事实：进程上一次运行后的残余信息会保留在 CPU 的状态中（也就是指 CPU 的缓存）。如果下一次仍然将该进程调度到同一个 CPU 上，就能避免缓存未命中等对 CPU 处理性能不利的情况，从而使得进程的运行更加高效。</p></blockquote><p>Linux 系统中每个进程的 <code>task_struct</code> 结构中有一个 <code>cpus_allowed</code> 位掩码，该掩码的位数与系统CPU 核数相同（若 CPU 启用了超线程则为核数乘以 2），通过修改该位掩码可以控制进程可运行在哪些特定 CPU 上。Linux 系统为我们提供了 CPU 亲和性相关的调用函数和一些操作的宏定义。</p><p>Linux 提供了一些宏定义来修改掩码，如 <code>CPU_ZERO()</code> （将位掩码全部设置为 0）和<code>CPU_SET()</code>（设置特定掩码位为 1）。CPU 的亲合力掩码用一个 <code>cpu_set_t</code> 结构体来表示一个 CPU 集合，下面的几个宏分别对这个掩码集进行操作:</p><ul><li><code>CPU_ZERO()</code>：清空一个集合。</li><li><code>CPU_SET()</code> 与 <code>CPU_CLR()</code> 分别对将一个给定的 CPU 号加到一个集合或者从一个集合中去掉。</li><li><code>CPU_ISSET()</code> 检查一个 CPU 号是否在这个集合中。</li></ul><p>然后还有两个接口帮助我们绑定进程到某个 CPU 或者 CPU 集合上。</p><ul><li><code>sched_setaffinity(pid_t pid， unsigned int cpusetsize， cpu_set_t *mask)</code><ul><li>该函数设置<strong>进程</strong>为 <code>pid</code> 的这个进程，让它运行在 <code>mask</code> 所设定的 CPU 上。如果 <code>pid</code> 的值为 0，则表示指定的是当前进程，使当前进程运行在 <code>mask</code> 所设定的那些 CPU 上。第二个参数 <code>cpusetsize</code> 是 mask 所指定的数的长度。通常设定为 <code>sizeof(cpu_set_t)</code>。如果当前 <code>pid</code> 所指定的进程此时没有运行在 <code>mask</code> 所指定的任意一个 CPU 上，则该指定的进程会从其它 CPU 上迁移到 <code>mask</code> 的指定的一个 CPU 上运行。</li></ul></li><li><code>sched_getaffinity(pid_t pid， unsigned int cpusetsize， cpu_set_t *mask)</code><ul><li>该函数获得 <code>pid</code> 所指示的进程的 CPU 位掩码，并将该掩码返回到 <code>mask</code> 所指向的结构中。即获得指定 <code>pid</code> 当前可以运行在哪些 CPU 上。同样，如果 <code>pid</code> 值为0，也表示的是当前进程。</li></ul></li></ul><p>因此，一个简易常见的将当前进程绑定到 CPU 某个核心（比如 6，CPU ID 从 0 开始）的示例如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cpu_set_t</span> mask;</span><br><span class="line"><span class="keyword">cpu_set_t</span> get;</span><br><span class="line">CPU_ZERO(&amp;mask);</span><br><span class="line"><span class="keyword">int</span> cpu_id = <span class="number">6</span>;</span><br><span class="line">CPU_SET(cpu_id， &amp;mask);</span><br><span class="line"><span class="keyword">if</span> (sched_setaffinity(<span class="number">0</span>， <span class="keyword">sizeof</span>(mask)， &amp;mask) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"WARNING: Could not set CPU Affinity， continuing。。。"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Bind process to cpu id: "</span> &lt;&lt; cpu_id &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Linux 还提供了线程绑定核心的接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadBindCPU</span><span class="params">(<span class="built_in">std</span>::thread &amp;thread, <span class="keyword">int</span> cpuID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> num_cpus = <span class="built_in">std</span>::thread::hardware_concurrency();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Launching "</span> &lt;&lt; num_cpus &lt;&lt; <span class="string">" threads\n"</span>;</span><br><span class="line">    <span class="keyword">cpu_set_t</span> mask;</span><br><span class="line">    CPU_ZERO(&amp;mask);</span><br><span class="line">    CPU_SET(cpuID, &amp;mask);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> rc = pthread_setaffinity_np(thread.native_handle(), <span class="keyword">sizeof</span>(<span class="keyword">cpu_set_t</span>), &amp;mask);</span><br><span class="line">    <span class="keyword">if</span> (rc != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Error calling pthread_setaffinity_np: "</span> &lt;&lt; rc &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread id: "</span> &lt;&lt; <span class="built_in">std</span>::hash&lt;<span class="built_in">std</span>::thread::id&gt;&#123;&#125;(thread.get_id()) &lt;&lt; <span class="string">", cpu id: "</span> &lt;&lt; cpuID &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看某个线程绑定的 CPU 核心，需要在线程内部调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sched_getcpu()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;有时候需要将程序绑定到固定 CPU 的某个核心上运行。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://murphypei.github.io/categories/C-C/"/>
    
    
      <category term="C++" scheme="https://murphypei.github.io/tags/C/"/>
    
      <category term="Linux" scheme="https://murphypei.github.io/tags/Linux/"/>
    
      <category term="CPU" scheme="https://murphypei.github.io/tags/CPU/"/>
    
      <category term="sched_setaffinity" scheme="https://murphypei.github.io/tags/sched-setaffinity/"/>
    
  </entry>
  
  <entry>
    <title>OpenBLAS 中矩阵运算函数学习</title>
    <link href="https://murphypei.github.io//blog/2019/09/cblas-gemm-gemv.html"/>
    <id>https://murphypei.github.io//blog/2019/09/cblas-gemm-gemv.html</id>
    <published>2019-09-25T06:20:11.000Z</published>
    <updated>2020-04-12T04:18:10.812Z</updated>
    
    <content type="html"><![CDATA[<p>GEMM 是矩阵乘法最成熟的优化计算方式，也有很多现成的优化好的库可以调用。</p><a id="more"></a><h2 id="OpenBLAS-矩阵计算"><a href="#OpenBLAS-矩阵计算" class="headerlink" title="OpenBLAS 矩阵计算"></a>OpenBLAS 矩阵计算</h2><p>OpenBLAS 库实现成熟优化的矩阵与矩阵乘法的函数 <code>cblas_sgemm</code> 和矩阵与向量乘法函数 <code>cblas_sgemv</code>，二者使用方法基本相同，参数较多，所以对参数的使用做个记录。</p><h4 id="矩阵与矩阵乘法"><a href="#矩阵与矩阵乘法" class="headerlink" title="矩阵与矩阵乘法"></a>矩阵与矩阵乘法</h4><p><code>cblas_sgemm</code> 计算的矩阵公式：<code>C=alpha*A*B+beta*C</code>，其中 <code>A</code>、<code>B</code>、<code>C</code> 都是矩阵，<code>C</code> 初始中存放的可以是偏置值。</p><p><code>cblas_sgemm</code> 函数定义：</p><p><code>cblas_sgemm(layout, transA, transB, M, N, K, alpha, A, LDA, B, LDB, beta, C, LDC);</code></p><ul><li><code>layout</code>：存储格式，有行主序（<code>CblasRowMajor</code>）和列主序（<code>CblasColMajor</code>），C/C++ 一般是行主序。</li><li><code>transA</code>：<code>A</code> 矩阵是否需要转置。</li><li><code>transB</code>：<code>B</code> 矩阵是否需要转置。</li><li><code>M</code>，<code>N</code>，<code>K</code>：<code>A</code> 矩阵经过 <code>transA</code> 之后的维度是 <code>M*K</code> ，<code>B</code> 矩阵经过 <code>transB</code> 之后的维度是 <code>K*N</code> ，<code>C</code> 矩阵的维度是 <code>M*N</code>。</li><li><code>LDA</code>，<code>LDB</code>，<code>LDC</code>：<strong>矩阵在 <code>trans</code> （如果需要转置）之前</strong>，在主维度方向的维度（如果是行主序，那这个参数就是列数）。</li></ul><p>示例代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cblas.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i, j;</span><br><span class="line">  <span class="keyword">float</span> a[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line">  <span class="keyword">float</span> b[<span class="number">6</span>]=&#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">2</span>&#125;;</span><br><span class="line">  <span class="keyword">float</span> c[<span class="number">6</span>]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">  cblas_sgemm(CblasRowMajor, CblasTrans, CblasTrans, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1.0</span>, a, <span class="number">3</span>, b, <span class="number">2</span>, <span class="number">0.0</span>, c, <span class="number">3</span>);</span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)&#123;</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; <span class="number">3</span>; ++j)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%f "</span>, c[i*<span class="number">3</span>+j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="矩阵与向量乘法"><a href="#矩阵与向量乘法" class="headerlink" title="矩阵与向量乘法"></a>矩阵与向量乘法</h4><p>矩阵与向量乘法本质也是矩阵与矩阵，只不过 <code>gemv</code> 比 <code>gemm</code> 要快一些，所以有时候也需要用 <code>gemv</code>。计算式：<code>C=alpha*A*b+beta*C</code></p><p><code>cblas_sgemv</code> 函数定义：</p><p><code>cblas_sgemv(layout, trans, M, N, alpha, A, LDA, b, 1, beta, C, 1)</code></p><p>参数的定义基本和 <code>gemm</code> 相同，<code>M</code> 和 <code>N</code> 是 <code>A</code> 的行数和列数，<code>b</code> 和 <code>C</code> 的列数都是 1。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;GEMM 是矩阵乘法最成熟的优化计算方式，也有很多现成的优化好的库可以调用。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://murphypei.github.io/categories/C-C/"/>
    
    
      <category term="OpenBLAS" scheme="https://murphypei.github.io/tags/OpenBLAS/"/>
    
      <category term="cblas_sgemm" scheme="https://murphypei.github.io/tags/cblas-sgemm/"/>
    
      <category term="cblas_sgemv" scheme="https://murphypei.github.io/tags/cblas-sgemv/"/>
    
      <category term="gemm" scheme="https://murphypei.github.io/tags/gemm/"/>
    
  </entry>
  
  <entry>
    <title>CUDA 函数前缀</title>
    <link href="https://murphypei.github.io//blog/2019/09/cuda-function-prefix.html"/>
    <id>https://murphypei.github.io//blog/2019/09/cuda-function-prefix.html</id>
    <published>2019-09-11T06:46:47.000Z</published>
    <updated>2020-04-12T04:18:10.812Z</updated>
    
    <content type="html"><![CDATA[<p>CUDA 函数前缀作为 CUDA 编程中一种特殊的使用技巧，其具有一定的限制意义。</p><a id="more"></a><p>CUDA 使用 cu 作为文件类型后缀，而在文件中又存在几种前缀，如果在修改编写 .cu 文件时不注意，会出现问题，比如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error : calling a __host__ <span class="keyword">function</span> from a __global__ <span class="keyword">function</span> is not allowed.</span><br></pre></td></tr></table></figure><p>在 CUDA 中有三种常见的前缀：<code>__device__</code>， <code>__global__</code>，<code>__host__</code>，其分别代表不同的意思，而这三个单词其实也是 CUDA 中常见的三种运行场景：</p><div class="table-container"><table><thead><tr><th style="text-align:center">限定符</th><th style="text-align:center">执行</th><th style="text-align:center">调用</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">__global__</td><td style="text-align:center">设备端执行</td><td style="text-align:center">可以从主机调用也可以从计算能力3以上的设备调用</td><td style="text-align:center">必须有一个void的返回类型</td></tr><tr><td style="text-align:center">__device__</td><td style="text-align:center">设备端执行</td><td style="text-align:center">设备端调用</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">__host__</td><td style="text-align:center">主机端执行</td><td style="text-align:center">主机调用</td><td style="text-align:center">可以省略</td></tr></tbody></table></div><p>因为函数前缀设定了函数的运行环境，因此对函数内部实现也做出了一定的限制，具体来说就是，device 函数因为只能在 GPU 上执行，因此不能调用常见的一些 C/C++ 函数（没有 GPU 实现），global 函数虽然能在 CPU 上运行，但是也能在 GPU 上面运行，因此同理。host 函数则没有这个限制，可以调用普通函数实现。</p><p>因此，在出现报错如：<code>error : calling a __host__ function from a __global__ function is not allowed.</code> 时候，即为将一个普通的函数错误地添加进入了 global 前缀定义函数，在 .cu 文件中是不允许的。</p><p>注意，有时候一个函数可以同时被多个前缀修饰的，比如 CUDA 10 浮点数的转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__host__ ​ __device__ ​ __half __float2half ( <span class="keyword">const</span> <span class="keyword">float</span>  a ) <span class="keyword">throw</span> ( )</span><br></pre></td></tr></table></figure><p>以上修饰这个函数可以在 host 端被调用，也可以在 device 端被调用。实际上这个函数在 CUDA 9.2 以后才允许在 host 端调用，其 CUDA 8.0 的版本：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__device__ ​ __half __float2half ( <span class="keyword">const</span> <span class="keyword">float</span>  a )</span><br></pre></td></tr></table></figure><p>因此，我们通过一个函数的前缀就可以判断这个函数的运行环境。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;CUDA 函数前缀作为 CUDA 编程中一种特殊的使用技巧，其具有一定的限制意义。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://murphypei.github.io/categories/C-C/"/>
    
    
      <category term="cuda" scheme="https://murphypei.github.io/tags/cuda/"/>
    
      <category term="global" scheme="https://murphypei.github.io/tags/global/"/>
    
      <category term="host" scheme="https://murphypei.github.io/tags/host/"/>
    
      <category term="device" scheme="https://murphypei.github.io/tags/device/"/>
    
  </entry>
  
</feed>
